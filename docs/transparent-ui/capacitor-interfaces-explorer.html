<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Capacitor Interface Explorer</title>
<style>
/* ═══════════════════════════════════════════════
   ROOT VARIABLES
   ═══════════════════════════════════════════════ */
:root {
  --bg: #0a0806;
  --surface: #140f04;
  --card: #1a1308;
  --border: #2a1f0a;
  --text: #e8dcc8;
  --muted: #8a7a60;
  --accent: #ffb000;
  --accent-dim: #4a3510;
  --cyan: #00c8ff;
  --green: #22c55e;
  --red: #ef4444;
  --purple: #a080ff;
  --source-hook: #ff8c00;
  --source-daemon: #00c8ff;
  --source-swift: #a080ff;
  --source-telemetry: #ffb000;
  --radius: 8px;
  --radius-sm: 4px;
}

/* ═══════════════════════════════════════════════
   RESET + BASE
   ═══════════════════════════════════════════════ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: "SF Mono", "Fira Code", "Cascadia Code", monospace;
  background: var(--bg);
  color: var(--text);
  font-size: 13px;
  line-height: 1.5;
  overflow: hidden;
  height: 100vh;
}

::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

/* ═══════════════════════════════════════════════
   HEADER
   ═══════════════════════════════════════════════ */
.header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  background: var(--surface);
}
.header h1 {
  font-size: 14px;
  font-weight: 600;
  color: var(--accent);
  white-space: nowrap;
}
.header .subtitle {
  font-size: 11px;
  color: var(--muted);
}

/* ═══════════════════════════════════════════════
   TAB BAR
   ═══════════════════════════════════════════════ */
.tab-bar {
  display: flex;
  gap: 2px;
  padding: 0 16px;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
  flex-shrink: 0;
}
.tab-btn {
  padding: 8px 20px;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  color: var(--muted);
  font: inherit;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: color 0.15s, border-color 0.15s;
}
.tab-btn:hover { color: var(--text); }
.tab-btn.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}

/* ═══════════════════════════════════════════════
   TAB CONTENT
   ═══════════════════════════════════════════════ */
.tab-content {
  display: none;
  flex: 1;
  overflow: hidden;
}
.tab-content.active { display: flex; flex-direction: column; }

/* ═══════════════════════════════════════════════
   LEARN TAB
   ═══════════════════════════════════════════════ */
.learn-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  flex-wrap: wrap;
}
.learn-main {
  display: grid;
  grid-template-columns: 240px 1fr;
  flex: 1;
  overflow: hidden;
}
.learn-steps {
  border-right: 1px solid var(--border);
  overflow-y: auto;
  padding: 12px;
  background: var(--surface);
}
.learn-steps h2 {
  font-size: 12px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 8px;
}
.learn-graph {
  position: relative;
  overflow: hidden;
}

/* ═══════════════════════════════════════════════
   LIVE TAB
   ═══════════════════════════════════════════════ */
.live-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 16px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  flex-wrap: wrap;
}
.live-main {
  display: grid;
  grid-template-columns: 360px 1fr;
  flex: 1;
  overflow: hidden;
}
.live-state {
  border-right: 1px solid var(--border);
  overflow-y: auto;
  padding: 12px;
  background: var(--surface);
}
.live-timeline {
  overflow-y: auto;
  padding: 12px;
}

/* ═══════════════════════════════════════════════
   SHARED CONTROLS
   ═══════════════════════════════════════════════ */
.control-group { display: flex; gap: 4px; align-items: center; }
.spacer { flex: 1; }
.ctrl, .flow-btn {
  padding: 4px 10px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--muted);
  font: inherit;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
}
.ctrl:hover, .flow-btn:hover { color: var(--text); border-color: var(--accent-dim); }
.ctrl:disabled { opacity: 0.3; cursor: default; }
.flow-btn.active {
  color: var(--accent);
  border-color: var(--accent);
  background: var(--accent-dim);
}

/* ═══════════════════════════════════════════════
   STEP LIST
   ═══════════════════════════════════════════════ */
.step-list { list-style: none; }
.step-item {
  display: block;
  width: 100%;
  text-align: left;
  padding: 6px 8px;
  margin-bottom: 2px;
  background: none;
  border: 1px solid transparent;
  border-radius: var(--radius-sm);
  color: var(--muted);
  font: inherit;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
}
.step-item:hover { background: var(--card); }
.step-item.active {
  color: var(--accent);
  border-color: var(--accent);
  background: var(--accent-dim);
}
.step-item.done { color: var(--cyan); opacity: 0.7; }
.step-item strong { font-weight: 500; }

/* ═══════════════════════════════════════════════
   GRAPH
   ═══════════════════════════════════════════════ */
.graph-wrap {
  width: 100%;
  height: 100%;
  overflow: auto;
  position: relative;
}
.graph {
  position: relative;
  width: 1320px;
  height: 760px;
}
.edge-layer {
  position: absolute;
  inset: 0;
  pointer-events: none;
}
.edge-layer path { pointer-events: stroke; }
.edge {
  fill: none;
  stroke: var(--border);
  stroke-width: 2;
  transition: stroke 0.3s, opacity 0.3s;
}
.edge.done { stroke: var(--cyan); opacity: 0.5; }
.edge.active { stroke: var(--cyan); stroke-width: 3; filter: drop-shadow(0 0 6px rgba(0,200,255,0.4)); }
.edge.selected { stroke: var(--accent); stroke-width: 3; }
.edge.dimmed { opacity: 0.15; }
.edge.debug-highlight { stroke-dasharray: 6 3; }
.edge-hit { cursor: pointer; }

.edge-label {
  position: absolute;
  transform: translate(-50%, -50%);
  padding: 2px 6px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  font-size: 10px;
  color: var(--muted);
  white-space: nowrap;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
}
.edge-label.visible { opacity: 1; }
.edge-label.dimmed { opacity: 0.15; }

.edge-failure-icon {
  position: absolute;
  transform: translate(-50%, -50%);
  width: 18px;
  height: 18px;
  display: none;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  cursor: help;
  z-index: 5;
}
.edge-failure-icon:hover .edge-failure-tooltip { display: block; }
.edge-failure-tooltip {
  display: none;
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px;
  width: 240px;
  font-size: 10px;
  z-index: 10;
}
.ft-scenario { color: var(--text); font-weight: 500; margin-bottom: 2px; }
.ft-symptom { color: var(--red); margin-bottom: 2px; }
.ft-recovery { color: var(--green); }
.ft-separator { border: none; border-top: 1px solid var(--border); margin: 6px 0; }

.node {
  position: absolute;
  width: 180px;
  height: 78px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
  font: inherit;
  color: var(--text);
}
.node:hover { border-color: var(--accent-dim); }
.node.active { border-color: var(--cyan); box-shadow: 0 0 12px rgba(0,200,255,0.15); }
.node.selected { border-color: var(--accent); box-shadow: 0 0 12px rgba(255,176,0,0.2); }
.node.dimmed { opacity: 0.2; }
.node .title { font-size: 12px; font-weight: 600; margin-bottom: 2px; }
.node .meta { font-size: 10px; color: var(--muted); }

/* ═══════════════════════════════════════════════
   MINIMAP
   ═══════════════════════════════════════════════ */
.minimap {
  position: absolute;
  bottom: 12px;
  right: 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 6px;
  z-index: 10;
  opacity: 0.8;
}
.minimap:hover { opacity: 1; }
.minimap h4 { font-size: 9px; color: var(--muted); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
.minimap canvas { display: block; cursor: pointer; }
.minimap-view {
  position: absolute;
  border: 1px solid var(--accent);
  border-radius: 2px;
  pointer-events: none;
}

/* ═══════════════════════════════════════════════
   DETAIL POPOVER (replaces right sidebar)
   ═══════════════════════════════════════════════ */
.overlay-backdrop {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 100;
  align-items: center;
  justify-content: center;
}
.detail-popover-panel {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  max-width: 500px;
  width: 90vw;
  max-height: 80vh;
  overflow-y: auto;
}
.detail-popover-panel h3 {
  font-size: 14px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 12px;
}

/* Detail tabs inside popover */
.detail-tabs {
  display: flex;
  gap: 2px;
  margin-bottom: 12px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 6px;
}
.detail-tab {
  padding: 4px 10px;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  color: var(--muted);
  font: inherit;
  font-size: 11px;
  cursor: pointer;
}
.detail-tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.detail-tab-content { display: none; font-size: 12px; }
.detail-tab-content.active { display: block; }
.detail-tab-content p { margin-bottom: 6px; }
.detail-tab-content code {
  background: var(--card);
  padding: 1px 4px;
  border-radius: 2px;
  font-size: 10px;
  color: var(--cyan);
}

.detail-section { margin-bottom: 12px; }
.detail-section h4 { font-size: 11px; color: var(--accent); margin-bottom: 4px; font-weight: 600; }
.detail-list { list-style: none; font-size: 11px; }
.detail-list li { padding: 2px 0; color: var(--text); }
.detail-list li::before { content: "· "; color: var(--muted); }

/* Data tables in popover */
.data-table { width: 100%; border-collapse: collapse; font-size: 11px; }
.data-table th { text-align: left; color: var(--muted); padding: 4px 6px; border-bottom: 1px solid var(--border); font-weight: 500; }
.data-table td { padding: 4px 6px; border-bottom: 1px solid var(--border); }
.table-name { color: var(--accent); font-weight: 500; display: block; }
.table-desc { color: var(--muted); font-size: 10px; }

/* State machine / policy rendering */
.state-diagram { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 8px; }
.state-chip {
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  border: 1px solid var(--border);
  color: var(--text);
}
.state-chip.working { border-color: var(--green); color: var(--green); }
.state-chip.ready { border-color: var(--cyan); color: var(--cyan); }
.state-chip.idle { border-color: var(--muted); }
.state-chip.compacting { border-color: var(--purple); color: var(--purple); }
.state-chip.waiting { border-color: var(--accent); color: var(--accent); }

.transition-table { width: 100%; border-collapse: collapse; font-size: 10px; margin-top: 6px; }
.transition-table th { text-align: left; color: var(--muted); padding: 3px 4px; border-bottom: 1px solid var(--border); }
.transition-table td { padding: 3px 4px; border-bottom: 1px solid var(--border); }

.policy-rules { list-style: none; }
.policy-rule { display: flex; align-items: center; gap: 6px; padding: 3px 0; font-size: 11px; }
.policy-rank { color: var(--muted); font-size: 10px; min-width: 20px; }
.policy-desc { flex: 1; }
.policy-status { font-size: 9px; padding: 1px 6px; border-radius: 8px; border: 1px solid var(--border); }
.policy-status.enabled { color: var(--green); border-color: var(--green); }
.policy-status.conditional { color: var(--accent); border-color: var(--accent); }
.policy-status.disabled { color: var(--muted); }

/* Boundary / confidence badges */
.boundary-badge {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 8px;
  font-size: 9px;
  border: 1px solid var(--border);
  color: var(--muted);
}
.boundary-badge.ipc-boundary { color: var(--cyan); border-color: var(--cyan); }
.boundary-badge.ffi-boundary { color: var(--purple); border-color: var(--purple); }
.boundary-badge.process-boundary { color: var(--source-hook); border-color: var(--source-hook); }
.boundary-badge.system-boundary { color: var(--red); border-color: var(--red); }
.boundary-badge.in-process { color: var(--green); border-color: var(--green); }

.latency-badge {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 8px;
  font-size: 9px;
  border: 1px solid var(--border);
  color: var(--muted);
}

.confidence { margin: 6px 0; }
.confidence-badge {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 8px;
  font-size: 9px;
  border: 1px solid var(--border);
}
.confidence-deterministic { color: var(--green); border-color: var(--green); }
.confidence-heuristic { color: var(--accent); border-color: var(--accent); }
.confidence-best-effort { color: var(--red); border-color: var(--red); }
.confidence-note { font-size: 10px; color: var(--muted); margin-left: 6px; }

/* Failure modes */
.failure-indicator { font-size: 11px; color: var(--red); font-weight: 500; margin-bottom: 6px; }
.failure-list { list-style: none; }
.failure-item { margin-bottom: 8px; font-size: 11px; }
.failure-item .scenario { color: var(--text); font-weight: 500; }
.failure-item .symptom { color: var(--red); }
.failure-item .recovery { color: var(--green); }

/* File details */
.files { font-size: 11px; }
.file { padding: 3px 0; color: var(--text); }
.file-detail summary { cursor: pointer; color: var(--cyan); }
.file-path { font-size: 10px; color: var(--muted); padding: 2px 0 2px 12px; word-break: break-all; }

/* ═══════════════════════════════════════════════
   CONTRACTS / SHORTCUTS OVERLAYS
   ═══════════════════════════════════════════════ */
.overlay-panel {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 24px;
  max-width: 600px;
  width: 90vw;
  max-height: 80vh;
  overflow-y: auto;
}
.overlay-panel h2 { font-size: 16px; color: var(--accent); margin-bottom: 16px; }
.overlay-dismiss { text-align: center; margin-top: 16px; font-size: 11px; color: var(--muted); }
.overlay-dismiss kbd {
  display: inline-block;
  padding: 1px 5px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 3px;
  font-size: 10px;
}

.contracts { display: flex; flex-direction: column; gap: 12px; }
.contract { padding: 12px; background: var(--card); border-radius: var(--radius); }
.contract h4 { font-size: 12px; color: var(--accent); margin-bottom: 4px; }
.contract p { font-size: 11px; color: var(--text); margin-bottom: 6px; }
.contract ul { list-style: none; font-size: 11px; }
.contract li { padding: 2px 0; color: var(--muted); }
.contract li::before { content: "· "; }

.overlay-shortcut {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 6px 0;
  font-size: 12px;
}
.key-col { min-width: 80px; text-align: right; }
.key-col kbd {
  display: inline-block;
  padding: 2px 6px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 3px;
  font-size: 11px;
  min-width: 20px;
  text-align: center;
}

/* ═══════════════════════════════════════════════
   LIVE TAB: KPI CARDS
   ═══════════════════════════════════════════════ */
.kpi-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 12px;
}
.kpi-card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 10px;
}
.kpi-card .kpi-label { font-size: 10px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
.kpi-card .kpi-value { font-size: 18px; font-weight: 600; color: var(--text); }
.kpi-card .kpi-value.healthy { color: var(--green); }
.kpi-card .kpi-value.unhealthy { color: var(--red); }

/* ═══════════════════════════════════════════════
   LIVE TAB: COLLAPSIBLE SECTIONS
   ═══════════════════════════════════════════════ */
.data-section-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 0;
  cursor: pointer;
  font-size: 12px;
  font-weight: 600;
  color: var(--text);
  user-select: none;
}
.data-section-header::before { content: "▾"; color: var(--muted); font-size: 10px; transition: transform 0.15s; }
.data-section-header.collapsed::before { transform: rotate(-90deg); }
.data-section-header.collapsed + .data-section-body { display: none; }
.data-section-body { padding-bottom: 8px; }

.payload-grid {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 1px 8px;
  font-size: 11px;
  padding: 4px 0;
}
.payload-key { color: var(--muted); white-space: nowrap; }
.payload-val { color: var(--text); word-break: break-all; }
.payload-val.bool-true { color: var(--green); }
.payload-val.bool-false { color: var(--red); }

.snapshot-item {
  padding: 6px 8px;
  margin-bottom: 4px;
  background: var(--card);
  border-radius: var(--radius-sm);
  font-size: 11px;
}

/* ═══════════════════════════════════════════════
   LIVE TAB: UNIFIED TIMELINE
   ═══════════════════════════════════════════════ */
.timeline-controls {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
  align-items: center;
}
.timeline-controls input[type="text"] {
  flex: 1;
  padding: 4px 8px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  font: inherit;
  font-size: 11px;
}
.timeline-controls select {
  padding: 4px 8px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  font: inherit;
  font-size: 11px;
}

.timeline-event {
  padding: 8px 10px;
  margin-bottom: 4px;
  background: var(--card);
  border-radius: var(--radius-sm);
  border-left: 4px solid var(--border);
  font-size: 11px;
}
.timeline-event.source-hook { border-left-color: var(--source-hook); }
.timeline-event.source-daemon { border-left-color: var(--source-daemon); }
.timeline-event.source-swift { border-left-color: var(--source-swift); }
.timeline-event.source-telemetry { border-left-color: var(--source-telemetry); }

.timeline-event .event-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2px;
}
.timeline-event .event-name { font-weight: 600; color: var(--text); }
.timeline-event .event-time { font-size: 10px; color: var(--muted); }
.timeline-event .event-detail { color: var(--muted); font-size: 10px; }
.timeline-event .event-payload { margin-top: 4px; }
.timeline-event.coalesced { opacity: 0.65; }
.timeline-event.coalesced:hover { opacity: 1; }
.event-count { font-size: 9px; color: var(--muted); background: rgba(255,255,255,0.06); padding: 1px 5px; border-radius: 8px; margin-left: 6px; font-weight: 500; }

.timeline-empty {
  padding: 20px;
  text-align: center;
  color: var(--muted);
  font-size: 12px;
}

/* ═══════════════════════════════════════════════
   LIVE TAB: ACTIVATION TRACE SCORING
   ═══════════════════════════════════════════════ */
.trace-section {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
}
.trace-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
  flex-wrap: wrap;
}
.trace-header h3 {
  font-size: 12px;
  font-weight: 600;
  color: var(--accent);
  margin: 0;
}
.trace-outcome {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.trace-outcome.primary { background: rgba(34,197,94,0.15); color: var(--green); border: 1px solid rgba(34,197,94,0.3); }
.trace-outcome.fallback { background: rgba(255,176,0,0.15); color: var(--accent); border: 1px solid rgba(255,176,0,0.3); }
.trace-outcome.none { background: rgba(239,68,68,0.15); color: var(--red); border: 1px solid rgba(239,68,68,0.3); }
.trace-action {
  font-size: 11px;
  color: var(--text);
}
.trace-action strong { color: var(--muted); font-weight: 500; }
.trace-config {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}
.trace-config-pill {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 8px;
  font-size: 9px;
  background: var(--card);
  border: 1px solid var(--border);
  color: var(--muted);
}
.trace-config-pill.active { color: var(--accent); border-color: rgba(255,176,0,0.3); }

.trace-grid {
  font-size: 11px;
  max-width: 640px;
}
.trace-grid-head {
  display: grid;
  grid-template-columns: 54px 52px auto 64px 30px 50px 36px;
  gap: 0 6px;
  padding: 4px 6px;
  border-bottom: 1px solid var(--border);
}
.trace-grid-head span {
  font-size: 9px;
  font-weight: 600;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.trace-row {
  display: grid;
  grid-template-columns: 54px 52px auto 64px 30px 50px 36px;
  gap: 0 6px;
  align-items: center;
  padding: 4px 6px;
  border-bottom: 1px solid var(--border);
  transition: opacity 0.15s;
}
.trace-row:last-child { border-bottom: none; }
.trace-row.winner {
  border-left: 3px solid var(--green);
  background: rgba(34,197,94,0.05);
  padding-left: 3px;
}
.trace-row.dead { opacity: 0.45; }
.trace-col-pid {
  font-family: "SF Mono", "Fira Code", monospace;
  font-weight: 600;
  white-space: nowrap;
}
.trace-selected-badge {
  display: inline-block;
  padding: 1px 5px;
  border-radius: 6px;
  font-size: 8px;
  font-weight: 700;
  background: rgba(34,197,94,0.15);
  color: var(--green);
  margin-left: 4px;
  letter-spacing: 0.5px;
}
.trace-col-match {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 8px;
  font-size: 9px;
  font-weight: 600;
  border: 1px solid var(--border);
  color: var(--muted);
}
.trace-col-match.exact { color: var(--green); border-color: rgba(34,197,94,0.4); background: rgba(34,197,94,0.08); }
.trace-col-match.child { color: var(--cyan); border-color: rgba(0,200,255,0.4); background: rgba(0,200,255,0.08); }
.trace-col-match.parent { color: var(--accent); border-color: rgba(255,176,0,0.4); background: rgba(255,176,0,0.08); }
.trace-col-match.none { color: var(--muted); }
.trace-col-cwd {
  color: var(--muted);
  font-size: 10px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  min-width: 0;
  max-width: 220px;
}
.trace-col-parent { font-size: 10px; color: var(--text); }
.trace-col-live { text-align: center; }
.trace-dot {
  display: inline-block;
  width: 7px;
  height: 7px;
  border-radius: 50%;
}
.trace-dot.alive { background: var(--green); box-shadow: 0 0 4px rgba(34,197,94,0.4); }
.trace-dot.dead { background: var(--red); opacity: 0.6; }
.trace-col-age {
  font-size: 10px;
  color: var(--muted);
  white-space: nowrap;
}
.trace-col-tmux {
  font-size: 10px;
  text-align: center;
}

.rank-toggle {
  display: block;
  width: 100%;
  text-align: left;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 9px;
  cursor: pointer;
  padding: 2px 0;
  font-family: inherit;
}
.rank-toggle:hover { color: var(--text); }
.rank-detail {
  display: none;
  padding: 4px 6px;
  font-size: 10px;
  color: var(--muted);
}
.rank-detail.open { display: block; }
.rank-step {
  display: inline-block;
  padding: 1px 5px;
  margin: 1px 2px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 4px;
  font-family: "SF Mono", "Fira Code", monospace;
  font-size: 9px;
}
.rank-arrow { color: var(--muted); margin: 0 2px; font-size: 9px; }

/* ═══════════════════════════════════════════════
   ARCHITECTURE OVERVIEW
   ═══════════════════════════════════════════════ */
.arch-overview { font-size: 11px; color: var(--muted); }
.arch-flow { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
.arch-node {
  padding: 2px 8px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  font-size: 10px;
  color: var(--text);
}
.arch-arrow { color: var(--muted); }

/* ═══════════════════════════════════════════════
   RESPONSIVE
   ═══════════════════════════════════════════════ */
@media (max-width: 900px) {
  .learn-main { grid-template-columns: 1fr; }
  .learn-steps { border-right: none; border-bottom: 1px solid var(--border); max-height: 200px; }
}
@media (max-width: 1000px) {
  .live-main { grid-template-columns: 1fr; }
  .live-state { border-right: none; border-bottom: 1px solid var(--border); max-height: 300px; }
}
</style>
</head>
<body>
<!-- ═══════════════════════════════════════════════
     HTML STRUCTURE
     ═══════════════════════════════════════════════ -->
<div class="app">
  <header class="header">
    <h1>Capacitor Interface Explorer</h1>
    <span class="subtitle">Architecture + Live Debugging</span>
  </header>

  <nav class="tab-bar">
    <button class="tab-btn active" data-tab="learn">Learn</button>
    <button class="tab-btn" data-tab="live">Live</button>
  </nav>

  <!-- ═══ LEARN TAB ═══ -->
  <div class="tab-content active" id="tab-learn">
    <section class="learn-controls" id="learn-controls"></section>
    <section class="learn-main">
      <aside class="learn-steps">
        <h2 id="flow-title">Flow</h2>
        <ol class="step-list" id="step-list"></ol>
      </aside>
      <div class="learn-graph">
        <div class="graph-wrap">
          <div class="graph" id="graph">
            <svg class="edge-layer" id="edge-layer" viewBox="0 0 1320 760" preserveAspectRatio="none" style="width:1320px;height:760px;">
              <defs>
                <marker id="arrow-future" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10" fill="none" stroke="var(--border)" stroke-width="1.5"/></marker>
                <marker id="arrow-done" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10" fill="none" stroke="var(--cyan)" stroke-width="1.5"/></marker>
                <marker id="arrow-active" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10" fill="none" stroke="var(--cyan)" stroke-width="1.5"/></marker>
              </defs>
            </svg>
          </div>
        </div>
      </div>
    </section>
  </div>

  <!-- ═══ LIVE TAB ═══ -->
  <div class="tab-content" id="tab-live">
    <section class="live-controls" id="live-controls">
      <label style="font-size:11px;color:var(--muted);">Trace URL:</label>
      <input type="text" id="live-url" style="width:260px;padding:3px 6px;background:var(--card);border:1px solid var(--border);border-radius:var(--radius-sm);color:var(--text);font:inherit;font-size:11px;">
      <button class="ctrl" id="live-toggle">Connect</button>
      <span id="live-status" style="font-size:10px;color:var(--muted);"></span>
      <div class="spacer"></div>
      <label style="font-size:11px;color:var(--muted);">Snapshot URL:</label>
      <input type="text" id="snapshot-url" style="width:260px;padding:3px 6px;background:var(--card);border:1px solid var(--border);border-radius:var(--radius-sm);color:var(--text);font:inherit;font-size:11px;">
      <button class="ctrl" id="snapshot-refresh">Refresh</button>
      <label style="font-size:10px;color:var(--muted);display:flex;align-items:center;gap:3px;"><input type="checkbox" id="snapshot-auto" checked> Auto</label>
    </section>
    <section class="live-main">
      <div class="live-state" id="live-state-col">
        <div class="kpi-grid" id="kpi-grid">
          <div class="kpi-card"><div class="kpi-label">Sessions</div><div class="kpi-value" id="kpi-sessions">--</div></div>
          <div class="kpi-card"><div class="kpi-label">Project</div><div class="kpi-value" id="kpi-project" style="font-size:12px;">--</div></div>
          <div class="kpi-card"><div class="kpi-label">Shells</div><div class="kpi-value" id="kpi-shells">--</div></div>
          <div class="kpi-card"><div class="kpi-label">Daemon</div><div class="kpi-value" id="kpi-daemon">--</div></div>
        </div>
        <div id="snapshot-sections"></div>
      </div>
      <div class="live-timeline" id="live-timeline-col">
        <div class="timeline-controls">
          <input type="text" id="timeline-filter" placeholder="Filter events...">
          <select id="timeline-source-filter">
            <option value="all">All Sources</option>
            <option value="hook">Hook</option>
            <option value="daemon">Daemon</option>
            <option value="swift">Swift</option>
            <option value="telemetry">Telemetry</option>
          </select>
          <button class="ctrl" id="timeline-clear">Clear</button>
          <button class="ctrl" id="trace-test-btn" title="Inject mock activation trace data">Test Trace</button>
        </div>
        <div id="timeline-events"><div class="timeline-empty">No events yet. Connect to a live trace or start the telemetry server.</div></div>
        <div id="activation-trace-section"></div>
      </div>
    </section>
  </div>

  <!-- ═══ GLOBAL OVERLAYS ═══ -->
  <div class="overlay-backdrop" id="detail-popover" style="display:none;">
    <div class="detail-popover-panel" id="detail-popover-panel"></div>
  </div>
  <div class="overlay-backdrop" id="contracts-overlay" style="display:none;">
    <div class="overlay-panel" id="contracts-panel"></div>
  </div>
  <div class="overlay-backdrop" id="shortcuts-overlay" style="display:none;">
    <div class="overlay-panel" id="shortcuts-panel"></div>
  </div>
</div>

<script>
/* ═══════════════════════════════════════════════════════════════
   PART 1: CONSTANTS + DATA (preserved from original)
   ═══════════════════════════════════════════════════════════════ */
const GRAPH_WIDTH = 1320;
const GRAPH_HEIGHT = 760;
const NODE_W = 180;
const NODE_H = 78;
const nodes = [
  { id: "claude", title: "Claude Code", subtitle: "hook event source", x: 40, y: 72, tag: "external CLI", layer: "external", purpose: "Emits Claude session lifecycle/tool events for the hook to forward." },
  { id: "shell", title: "Shell Prompt Hook", subtitle: "cwd event source", x: 40, y: 260, tag: "zsh/bash/fish", layer: "external", purpose: "Reports current cwd/tty context so daemon can map sessions to shells." },
  { id: "hudhook", title: "hud-hook (Rust CLI)", subtitle: "normalizes + forwards events", x: 280, y: 162, tag: "core/hud-hook", layer: "process", purpose: "Normalizes hook payloads into EventEnvelope and forwards to daemon IPC.", notes: ["Runs as a lightweight CLI invoked by Claude/shell hooks."] },
  { id: "daemon", title: "capacitor-daemon", subtitle: "single writer + reducer", x: 540, y: 162, tag: "core/daemon", layer: "daemon", purpose: "Validates events, reduces them into sessions/activity, and serves snapshots over IPC.",
    exposes: ["get_sessions / get_project_states / get_shell_state / get_process_liveness", "event ingestion with strict validation"],
    derivedFrom: ["Replays event log on startup if sessions table is missing or stale", "Rebuilds shell_state from events if table is empty"],
    rules: ["Working → Ready after ~60s tool inactivity (last_event in post_tool_use/post_tool_use_failure/task_completed, tools_in_flight=0)", "Session TTLs: Working/Waiting/Compacting 20m, Ready 30m, Idle 10m", "Dead non-idle sessions reconcile to Idle when PID liveness fails (startup + periodic)"],
    notes: ["Single-writer; clients are read-only via IPC snapshots", "Event types: session_start, user_prompt_submit, pre_tool_use, post_tool_use, post_tool_use_failure, permission_request, pre_compact, notification, stop, task_completed, subagent_start, subagent_stop, teammate_idle, session_end, shell_cwd (subagent/teammate events ignored by reducer)"],
    stateMachine: { name: "SessionState FSM", states: ["Working", "Ready", "Idle", "Compacting", "Waiting"],
      transitions: [
        { from: "*", to: "Ready", trigger: "SessionStart", condition: "session not active" },
        { from: "Ready", to: "Working", trigger: "UserPromptSubmit" },
        { from: "*", to: "Working", trigger: "PreToolUse" },
        { from: "*", to: "Working", trigger: "PostToolUse" },
        { from: "*", to: "Working", trigger: "PostToolUseFailure" },
        { from: "*", to: "Waiting", trigger: "PermissionRequest" },
        { from: "*", to: "Compacting", trigger: "PreCompact" },
        { from: "*", to: "Waiting", trigger: "Notification", condition: "permission_prompt" },
        { from: "*", to: "Ready", trigger: "Notification", condition: "idle_prompt" },
        { from: "*", to: "Ready", trigger: "TaskCompleted" },
        { from: "Working", to: "Ready", trigger: "Auto-ready", condition: ">=60s tool inactivity, tools_in_flight=0" },
        { from: "*", to: "Ready", trigger: "Stop", condition: "hook not active, event not stale" },
        { from: "Compacting", to: "Working", trigger: "UserPromptSubmit" },
        { from: "*", to: null, trigger: "SubagentStart/SubagentStop/TeammateIdle", condition: "ignored" },
        { from: "*", to: null, trigger: "SessionEnd", condition: "deletes session" }
      ], currentState: null },
    failureModes: [
      { scenario: "Stale event arrives (older timestamp)", symptom: "Session state doesn't update", mitigation: "reduce_session() compares timestamps, skips stale events" },
      { scenario: "Duplicate SessionStart for active session", symptom: "State resets unexpectedly", mitigation: "Guard: only transitions if session not already active" }
    ] },
  { id: "sqlite", title: "state.db (SQLite WAL)", subtitle: "authoritative state", x: 810, y: 112, tag: "~/.capacitor/daemon", layer: "persistence", purpose: "Durable store for daemon state: append-only events plus materialized tables.",
    dataModel: [
      { name: "events", description: "Append-only event log (full payloads).", columns: ["id", "recorded_at", "event_type", "session_id", "pid", "payload"] },
      { name: "sessions", description: "Materialized session state per session_id.", columns: ["session_id", "pid", "state", "cwd", "project_id", "project_path", "updated_at", "state_changed_at", "last_event", "last_activity_at", "tools_in_flight", "ready_reason"] },
      { name: "activity", description: "File/tool activity history for sessions.", columns: ["session_id", "project_path", "file_path", "tool_name", "recorded_at"] },
      { name: "shell_state", description: "Latest cwd/tty/parent_app per pid for fast focus checks.", columns: ["pid", "cwd", "tty", "parent_app", "tmux_session", "tmux_client_tty", "updated_at"] },
      { name: "process_liveness", description: "PID identity + last seen time for pruning.", columns: ["pid", "proc_started", "last_seen_at"] },
      { name: "tombstones", description: "Session deletion TTLs to prevent resurrection.", columns: ["session_id", "created_at", "expires_at"] }
    ],
    notes: ["WAL enabled; synchronous=NORMAL; busy_timeout=5s", "Single-writer daemon; clients read via IPC snapshots"] },
  { id: "swift", title: "Swift AppState", subtitle: "polling + UI state", x: 260, y: 520, tag: "apps/swift", layer: "ui", purpose: "Owns app UI state; polls daemon and surfaces activation traces.",
    polling: ["Daemon snapshots every ~2s (ShellStateStore/AppState)", "Staleness timer ~2s; hook diagnostic ~10s; health check ~16s; stats refresh ~30s"],
    notes: ["Activation traces show in Debug UI when CAPACITOR_ACTIVATION_TRACE=1"] },
  { id: "daemonClient", title: "DaemonClient.swift", subtitle: "IPC transport client", x: 540, y: 430, tag: "JSON request/response", layer: "ui", purpose: "Encodes JSON IPC requests and decodes daemon snapshot responses." },
  { id: "hudEngine", title: "HudEngine (Rust)", subtitle: "UniFFI facade", x: 540, y: 590, tag: "core/hud-core", layer: "logic", purpose: "Rust core facade for Swift; loads daemon state and computes decisions.",
    exposes: ["loadDashboard(), resolveActivation(...), resolveActivationWithTrace(...)"] },
  { id: "resolver", title: "resolve_activation()", subtitle: "pure decision logic", x: 810, y: 590, tag: "Rust module", layer: "logic", purpose: "Pure policy engine that ranks candidates and returns ActivationDecision.",
    notes: ["Optional decision trace emitted when tracing is enabled"],
    policyTable: { name: "Activation Selection Policy",
      rules: [
        { rank: 0, description: "live shells beat dead shells", enabled: true },
        { rank: 1, description: "path specificity: exact > child > parent", enabled: true },
        { rank: 2, description: "tmux preference (only when attached and path ties)", enabled: false, condition: "prefer_tmux && path ranks equal" },
        { rank: 3, description: "known parent app beats unknown parent app", enabled: true },
        { rank: 4, description: "most recent timestamp wins (invalid timestamps lose)", enabled: true },
        { rank: 5, description: "higher PID breaks ties deterministically", enabled: true }
      ], context: { prefer_tmux: false } },
    failureModes: [
      { scenario: "Multiple shells at same path with different recency", symptom: "Wrong shell selected", mitigation: "Policy table ranks by liveness > path > tmux > parent > timestamp > pid" },
      { scenario: "HOME directory matches all child paths", symptom: "Home shell selected instead of project shell", mitigation: "HOME exclusion logic prevents broad matching" }
    ] },
  { id: "launcher", title: "TerminalLauncher", subtitle: "build context + execute", x: 810, y: 430, tag: "Swift model", layer: "executor", purpose: "Builds execution plan and drives activation + trace logging." },
  { id: "executor", title: "ActivationActionExecutor", subtitle: "adapter-driven routing", x: 1060, y: 430, tag: "Swift protocol layer", layer: "executor", purpose: "Routes ActivationAction through adapters; handles fallback execution.",
    failureModes: [
      { scenario: "Primary action fails (app not found, tmux error)", symptom: "Terminal doesn't activate", mitigation: "Executor triggers fallback action from ActivationDecision" },
      { scenario: "Ghostty window targeting is heuristic", symptom: "Wrong window activated", mitigation: "Falls back to ActivateApp (app-level, not window-level)" }
    ] },
  { id: "fallback", title: "Fallback Plan", subtitle: "secondary ActivationAction", x: 1120, y: 580, tag: "launcher fallback", layer: "executor", purpose: "Secondary activation action used when the primary path fails." },
  { id: "os", title: "tmux + macOS APIs", subtitle: "Process, AppleScript, AppKit", x: 1060, y: 220, tag: "outside world", layer: "external", purpose: "External side effects: tmux commands, AppleScript, NSWorkspace focus." }
];

const edges = [
  { id: "e1", from: "claude", to: "hudhook", label: "hook stdin", name: "Claude hook event -> hud-hook", boundary: "Process boundary", boundaryType: "process-boundary", latencyClass: "instant", directionality: "fire-and-forget", request: "Hook JSON on stdin (SessionStart, PreToolUse, Stop, ...)", response: "Exit status",
    files: ["/Users/petepetrash/Code/capacitor/core/hud-hook/src/main.rs", "/Users/petepetrash/Code/capacitor/core/hud-hook/src/handle.rs"],
    failureModes: [{ scenario: "hud-hook binary missing or not executable", symptom: "Hook events silently dropped", recovery: "Claude session continues unaffected; Capacitor loses visibility" }] },
  { id: "e2", from: "shell", to: "hudhook", label: "cwd command", name: "Shell cwd hook -> hud-hook cwd", boundary: "Process boundary", boundaryType: "process-boundary", latencyClass: "instant", directionality: "fire-and-forget", request: "hud-hook cwd <path> <pid> <tty>", response: "Exit status",
    files: ["/Users/petepetrash/Code/capacitor/core/hud-hook/src/cwd.rs"] },
  { id: "e3", from: "hudhook", to: "daemon", label: "IPC method=event", name: "hud-hook -> daemon event envelope", boundary: "Unix socket JSON IPC", boundaryType: "ipc-boundary", latencyClass: "fast", directionality: "request-response", request: "Request { protocol_version, method: event, params: EventEnvelope }", response: "Response { ok, data: { accepted: true } }",
    files: ["/Users/petepetrash/Code/capacitor/core/hud-hook/src/daemon_client.rs", "/Users/petepetrash/Code/capacitor/docs/daemon-ipc.md"],
    failureModes: [{ scenario: "Daemon socket closed or daemon not running", symptom: "Connection refused; hook exits with error", recovery: "Hook exits with failure code; Claude session continues" }, { scenario: "JSON parse error in daemon", symptom: "Error response returned", recovery: "Event dropped; daemon logs error" }] },
  { id: "e4", from: "daemon", to: "sqlite", label: "reduce + persist", name: "Daemon reducer updates materialized state", boundary: "In-process DB boundary", boundaryType: "in-process", latencyClass: "instant", directionality: "request-response", request: "Session and activity reductions from event stream", response: "Committed SQLite rows",
    files: ["/Users/petepetrash/Code/capacitor/core/daemon/src/reducer.rs", "/Users/petepetrash/Code/capacitor/core/daemon/src/db.rs"],
    failureModes: [{ scenario: "Stale event (older timestamp than current state)", symptom: "Event silently skipped", recovery: "is_event_stale() comparison prevents state regression" }] },
  { id: "e5", from: "swift", to: "daemonClient", label: "poll timer", name: "Swift polling tick triggers daemon request", boundary: "In-app API boundary", boundaryType: "in-process", latencyClass: "instant", directionality: "request-response", request: "fetchSessions(), fetchProjectStates(), fetchShellState()", response: "Decoded Swift structs",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/AppState.swift", "/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/ShellStateStore.swift"] },
  { id: "e6", from: "daemonClient", to: "daemon", label: "get_project_states", name: "DaemonClient -> daemon query", boundary: "Unix socket JSON IPC", boundaryType: "ipc-boundary", latencyClass: "fast", directionality: "request-response", request: "method: get_project_states / get_sessions / get_shell_state", response: "JSON response body",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/DaemonClient.swift", "/Users/petepetrash/Code/capacitor/docs/daemon-ipc.md"],
    failureModes: [{ scenario: "Daemon socket closed", symptom: "Connection refused; loadDashboard() returns empty", recovery: "Swift shows 'daemon unavailable' state" }] },
  { id: "e7", from: "daemon", to: "daemonClient", label: "snapshot data", name: "Daemon snapshot -> Swift decode", boundary: "JSON schema boundary", boundaryType: "ipc-boundary", latencyClass: "fast", directionality: "request-response", request: "Response data payload", response: "[DaemonSession], [DaemonProjectState], ShellCwdState",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/DaemonClient.swift"] },
  { id: "e8", from: "daemonClient", to: "swift", label: "state update", name: "DaemonClient result -> Swift stores/UI", boundary: "In-app model boundary", boundaryType: "in-process", latencyClass: "instant", directionality: "fire-and-forget", request: "Decoded snapshots", response: "Published state refresh",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/AppState.swift", "/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/SessionStateManager.swift"] },
  { id: "e9", from: "swift", to: "hudEngine", label: "UniFFI call", name: "Swift -> HudEngine facade", boundary: "FFI boundary (Swift <-> Rust)", boundaryType: "ffi-boundary", latencyClass: "fast", directionality: "request-response", request: "loadDashboard(), resolveActivation(...)", response: "Rust records/enums as Swift types",
    files: ["/Users/petepetrash/Code/capacitor/core/hud-core/src/engine.rs", "/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Bridge/hud_core.swift"],
    failureModes: [{ scenario: "Rust panic across FFI boundary", symptom: "Swift receives nil from UniFFI call", recovery: "Swift catches and falls back to ActivatePriorityFallback" }, { scenario: "Invalid UTF-8 in Rust string", symptom: "UniFFI conversion fails", recovery: "Rust sanitizes strings before crossing FFI" }] },
  { id: "e10", from: "hudEngine", to: "daemon", label: "state::daemon IPC", name: "HudEngine reads daemon snapshots", boundary: "Rust -> daemon IPC", boundaryType: "ipc-boundary", latencyClass: "fast", directionality: "request-response", request: "get_sessions / health checks", response: "daemon state snapshot",
    files: ["/Users/petepetrash/Code/capacitor/core/hud-core/src/state/daemon.rs", "/Users/petepetrash/Code/capacitor/core/hud-core/src/sessions.rs"] },
  { id: "e11", from: "hudEngine", to: "resolver", label: "resolve_activation", name: "HudEngine delegates activation decision", boundary: "Rust module boundary", boundaryType: "in-process", latencyClass: "instant", directionality: "request-response", request: "project_path + shell_state + tmux_context", response: "ActivationDecision { primary, fallback, reason }",
    files: ["/Users/petepetrash/Code/capacitor/core/hud-core/src/activation.rs", "/Users/petepetrash/Code/capacitor/core/hud-core/src/engine.rs"] },
  { id: "e12", from: "resolver", to: "launcher", label: "decision DTO", name: "Rust decision -> Swift execution plan", boundary: "FFI boundary (DTO transfer)", boundaryType: "ffi-boundary", latencyClass: "fast", directionality: "request-response", request: "ActivationDecision over UniFFI", response: "Swift enum + fallback available",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/TerminalLauncher.swift", "/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Bridge/hud_core.swift"] },
  { id: "e13", from: "launcher", to: "executor", label: "execute(action)", name: "TerminalLauncher -> ActivationActionExecutor", boundary: "Swift interface boundary", boundaryType: "in-process", latencyClass: "instant", directionality: "request-response", request: "ActivationAction + project metadata", response: "Bool success/failure",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/TerminalLauncher.swift", "/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/ActivationActionExecutor.swift"] },
  { id: "e14", from: "executor", to: "os", label: "adapter calls", name: "Executor routes via adapters/protocols", boundary: "Swift -> system boundary", boundaryType: "system-boundary", latencyClass: "blocking", directionality: "request-response", request: "tmux switch-client, AppleScript, NSWorkspace, kitty remote", response: "Command/app activation result", confidence: "heuristic", confidenceNote: "Ghostty window targeting is heuristic; exact window selection is not deterministic.",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/ActivationAdapters.swift", "/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/ActivationActionExecutor.swift"],
    failureModes: [{ scenario: "tmux command failure (no client attached)", symptom: "switch-client returns error", recovery: "Falls back to LaunchTerminalWithTmux or LaunchNewTerminal" }, { scenario: "AppleScript blocked by user focus", symptom: "App activation returns false", recovery: "Launcher tries fallback action" }, { scenario: "kitty remote control disabled", symptom: "kitty@ command fails", recovery: "Falls back to ActivateApp for kitty" }] },
  { id: "e15", from: "os", to: "executor", label: "result", name: "External side effect -> executor outcome", boundary: "system callback boundary", boundaryType: "system-boundary", latencyClass: "blocking", directionality: "request-response", request: "Exit codes, bool checks, accessibility/app state", response: "Bool for fallback orchestration", confidence: "best-effort", confidenceNote: "System callbacks are best-effort; user focus may be blocked or overridden.",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/TerminalLauncher.swift"],
    failureModes: [{ scenario: "User switches focus during activation", symptom: "Target app loses focus immediately", recovery: "No retry; activation considered best-effort" }, { scenario: "Accessibility permissions denied", symptom: "AppleScript cannot control applications", recovery: "User must grant permission in System Preferences" }] },
  { id: "e16", from: "executor", to: "fallback", label: "primary failed", name: "Executor flags primary activation failure", boundary: "Swift control-flow boundary", boundaryType: "in-process", latencyClass: "instant", directionality: "fire-and-forget", request: "Bool failure + fallback intent", response: "Fallback action selected",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/ActivationActionExecutor.swift", "/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/TerminalLauncher.swift"] },
  { id: "e17", from: "fallback", to: "os", label: "fallback adapters", name: "Fallback execution routes to adapters", boundary: "Swift -> system boundary", boundaryType: "system-boundary", latencyClass: "blocking", directionality: "request-response", request: "Fallback ActivationAction", response: "Command/app activation result", confidence: "heuristic", confidenceNote: "Fallback uses the same adapter surface; Ghostty targeting remains heuristic.",
    files: ["/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/ActivationAdapters.swift", "/Users/petepetrash/Code/capacitor/apps/swift/Sources/Capacitor/Models/ActivationActionExecutor.swift"] }
];

const flows = [
  { id: "realtime", name: "Realtime Session Tracking", description: "How Claude/shell events become authoritative daemon state and then update Swift UI through polling.",
    steps: [
      { edgeId: "e1", note: "Claude hook event enters the hook binary." },
      { edgeId: "e2", note: "Shell cwd hook reports ambient context in parallel." },
      { edgeId: "e3", note: "hook binary sends validated EventEnvelope over daemon IPC." },
      { edgeId: "e4", note: "daemon reducer updates SQLite materialized state." },
      { edgeId: "e5", note: "Swift timer triggers daemon polling requests." },
      { edgeId: "e6", note: "DaemonClient sends get_project_states/get_sessions." },
      { edgeId: "e7", note: "daemon replies with typed snapshots." },
      { edgeId: "e8", note: "Swift stores publish updated project/session state." }
    ] },
  { id: "dashboard", name: "Dashboard + Rust Core", description: "How the Swift app crosses the UniFFI boundary into HudEngine, and how Rust reads daemon snapshots for state-aware responses.",
    steps: [
      { edgeId: "e9", note: "Swift calls HudEngine (e.g. loadDashboard)." },
      { edgeId: "e10", note: "HudEngine's state module queries daemon snapshots." },
      { edgeId: "e7", note: "daemon responds with snapshot payloads." },
      { edgeId: "e9", note: "Rust DTOs map back into Swift types via UniFFI." },
      { edgeId: "e8", note: "Swift updates UI from returned data." }
    ] },
  { id: "activation", name: "Project Activation Path", description: "How a project click becomes an ActivationDecision in Rust, then executes through Swift adapters to tmux/macOS APIs.",
    steps: [
      { edgeId: "e13", note: "Launcher delegates action execution path." },
      { edgeId: "e9", note: "Launcher calls resolveActivation via HudEngine." },
      { edgeId: "e11", note: "HudEngine computes decision in activation resolver." },
      { edgeId: "e12", note: "Swift receives ActivationDecision with primary/fallback." },
      { edgeId: "e13", note: "Executor routes by ActivationAction variant." },
      { edgeId: "e14", note: "Adapters call tmux + app focus APIs." },
      { edgeId: "e15", note: "Executor returns success/failure to launcher." },
      { edgeId: "e16", note: "If primary fails: executor flags fallback execution." },
      { edgeId: "e17", note: "Fallback adapters reattempt tmux/app focus APIs." },
      { edgeId: "e15", note: "Fallback result determines final activation outcome." }
    ] }
];

const contracts = [
  { title: "Daemon IPC Contract (v1)", summary: "Single JSON request/response per Unix socket connection. daemon is single writer.",
    bullets: ["Transport: ~/.capacitor/daemon.sock (one request per connection)", "Envelope: { protocol_version, method, id?, params? } → { ok, data | error }", "Methods: event, get_health, get_shell_state, get_sessions, get_project_states, get_process_liveness", "Validation: event_id ≤ 128, recorded_at RFC3339, session events require session_id/pid/cwd", "Errors: invalid_params, protocol_mismatch, invalid_timestamp, missing_field (no legacy fallback)"] },
  { title: "State DB (state.db)", summary: "Single-writer SQLite store backing daemon snapshots.",
    bullets: ["Tables: events, sessions, activity, shell_state, process_liveness, tombstones", "events are append-only; sessions/activity/shell_state are materialized for fast reads", "WAL enabled; daemon is the only writer; clients read via IPC"] },
  { title: "Session Lifecycle + Replay", summary: "Daemon replays and prunes to keep state accurate across restarts.",
    bullets: ["Replays events if sessions table missing or stale", "Rebuilds shell_state from events if table is empty", "Working → Ready after ~60s inactivity (event-guarded); TTLs: Active 20m, Ready 30m, Idle 10m", "Dead non-idle sessions reconcile to Idle at startup and every ~15s", "Process liveness rows pruned after 24h"] },
  { title: "Swift <-> Rust (UniFFI)", summary: "HudEngine is the stable facade. Rust returns typed DTOs/enums, Swift executes UI/platform behavior.",
    bullets: ["Boundary owner: core/hud-core/src/engine.rs", "Bindings: apps/swift/Sources/Capacitor/Bridge/hud_core.swift", "Important call: resolveActivation(projectPath, shellState, tmuxContext)", "Design: Rust decides, Swift executes side effects"] },
  { title: "Activation Adapter Layer", summary: "ActivationActionExecutor isolates orchestration from concrete terminal/system calls.",
    bullets: ["Protocols: ActivationActionDependencies, TmuxClient, TerminalDiscovery, TerminalLauncherClient", "Adapters: ActivationAdapters.swift wraps concrete handlers", "Allows deterministic unit tests with stubs", "Ghostty still uses heuristic activation where exact window targeting is unavailable"] }
];

/* ═══════════════════════════════════════════════════════════════
   PART 2: URL DEFAULTS + STATE + DOM REFS
   ═══════════════════════════════════════════════════════════════ */
const params = new URLSearchParams(window.location.search);
const defaultLiveUrl = params.get("live") || "http://localhost:9133/activation-trace";
const defaultSnapshotUrl = params.get("snapshot") || "http://localhost:9133/daemon-snapshot";
const defaultTelemetryUrl = params.get("telemetry") || "http://localhost:9133/telemetry";

const state = {
  activeTab: "learn",
  flowId: flows[0].id,
  stepIndex: 0,
  playing: false,
  timer: null,
  selectedNodeId: null,
  selectedEdgeId: null,
  detailTab: "overview",
  detailPopoverOpen: false,
  liveConnected: false,
  liveUrl: defaultLiveUrl,
  liveError: null,
  liveSource: null,
  liveTransport: null,
  snapshotUrl: defaultSnapshotUrl,
  snapshotAuto: true,
  snapshotTimer: null,
  snapshotError: null,
  snapshotData: null,
  snapshotLastSuccess: null,
  telemetryUrl: defaultTelemetryUrl,
  telemetryAuto: true,
  telemetryTimer: null,
  telemetryError: null,
  telemetrySseSource: null,
  unifiedEvents: [],
  unifiedEventIds: new Set(),
  timelineFilter: "",
  timelineSourceFilter: "all",
  lastDecision: null,
  trace: []
};

/* DOM refs */
const graphEl = document.getElementById("graph");
const graphWrapEl = document.querySelector(".graph-wrap");
const edgeLayer = document.getElementById("edge-layer");
const flowTitleEl = document.getElementById("flow-title");
const stepListEl = document.getElementById("step-list");

const controlState = {
  flowButtons: new Map(),
  stepBack: null,
  stepForward: null,
  playPause: null,
  stepCounter: null,
  minimap: null,
  minimapCanvas: null,
  minimapView: null,
  minimapScale: 1
};

/* ═══════════════════════════════════════════════════════════════
   PART 3: UTILITY FUNCTIONS
   ═══════════════════════════════════════════════════════════════ */
function byId(list, id) { return list.find(item => item.id === id); }
function nodeCenter(node) { return { x: node.x + NODE_W / 2, y: node.y + NODE_H / 2 }; }
function clamp(value, min, max) { return Math.min(Math.max(value, min), max); }
function currentFlow() { return byId(flows, state.flowId) || flows[0]; }

function flowEdgeState(edgeId) {
  const flow = currentFlow();
  const indices = flow.steps.reduce((acc, step, idx) => { if (step.edgeId === edgeId) acc.push(idx); return acc; }, []);
  if (indices.length === 0) return "neutral";
  if (indices.includes(state.stepIndex)) return "active";
  if (Math.max(...indices) < state.stepIndex) return "done";
  if (Math.min(...indices) > state.stepIndex) return "future";
  return "done";
}

function findStepIndex(flow, edgeId) { return flow.steps.findIndex(step => step.edgeId === edgeId); }

function edgePath(a, b) {
  const dx = b.x - a.x;
  const c1x = a.x + Math.max(60, Math.abs(dx) * 0.35) * Math.sign(dx || 1);
  const c2x = b.x - Math.max(60, Math.abs(dx) * 0.35) * Math.sign(dx || 1);
  return "M " + a.x + " " + a.y + " C " + c1x + " " + a.y + ", " + c2x + " " + b.y + ", " + b.x + " " + b.y;
}

function edgeMidpoint(a, b) {
  const t = 0.5;
  const c1x = a.x + Math.max(60, Math.abs(b.x - a.x) * 0.35) * Math.sign((b.x - a.x) || 1);
  const c2x = b.x - Math.max(60, Math.abs(b.x - a.x) * 0.35) * Math.sign((b.x - a.x) || 1);
  const x = Math.pow(1-t,3)*a.x + 3*Math.pow(1-t,2)*t*c1x + 3*(1-t)*Math.pow(t,2)*c2x + Math.pow(t,3)*b.x;
  const y = Math.pow(1-t,3)*a.y + 3*Math.pow(1-t,2)*t*a.y + 3*(1-t)*Math.pow(t,2)*b.y + Math.pow(t,3)*b.y;
  return { x, y };
}

function centerOnActive() {
  if (!graphWrapEl) return;
  const flow = currentFlow();
  let target = null;
  if (state.selectedNodeId) {
    target = nodeCenter(byId(nodes, state.selectedNodeId));
  } else {
    const edgeId = state.selectedEdgeId || flow.steps[state.stepIndex].edgeId;
    const edge = byId(edges, edgeId);
    const from = nodeCenter(byId(nodes, edge.from));
    const to = nodeCenter(byId(nodes, edge.to));
    target = edgeMidpoint(from, to);
  }
  if (!target) return;
  const maxLeft = GRAPH_WIDTH - graphWrapEl.clientWidth;
  const maxTop = GRAPH_HEIGHT - graphWrapEl.clientHeight;
  const left = clamp(target.x - graphWrapEl.clientWidth / 2, 0, Math.max(0, maxLeft));
  const top = clamp(target.y - graphWrapEl.clientHeight / 2, 0, Math.max(0, maxTop));
  graphWrapEl.scrollTo({ left, top, behavior: "smooth" });
}

function classifyTraceKind(payload, edge) {
  const action = (payload.action || payload.type || payload.kind || "").toLowerCase();
  if (action.includes("error") || action.includes("fail")) return "error";
  if (action.includes("poll")) return "poll";
  if (action.includes("activate") || action.includes("resolve")) return "activate";
  if (action.includes("hook")) return "hook";
  if (edge) {
    const label = (edge.label + " " + edge.name).toLowerCase();
    if (label.includes("poll") || label.includes("get_")) return "poll";
    if (label.includes("hook")) return "hook";
    if (label.includes("activate") || label.includes("activation")) return "activate";
  }
  return "";
}

function classifyEventSource(event) {
  const name = (event.name || event.type || event.event || "").toLowerCase();
  if (name.includes("hook") || name.includes("cwd")) return "hook";
  if (name.includes("daemon") || name.includes("ipc") || name.includes("health")) return "daemon";
  if (name.includes("activation") || name.includes("swift") || name.includes("ui")) return "swift";
  return "telemetry";
}

// NOTE: This is a standalone local debugging tool (not user-facing).
// All innerHTML content comes from hardcoded data arrays, not user input.
function formatPayload(obj, depth) {
  if (depth === undefined) depth = 0;
  if (depth > 2 || !obj || typeof obj !== "object") {
    return '<span class="payload-val">' + (obj === null ? "null" : String(obj)) + '</span>';
  }
  const entries = Array.isArray(obj) ? obj.map(function(v, i) { return [i, v]; }) : Object.entries(obj);
  if (entries.length === 0) return '<span class="payload-val">{}</span>';
  return '<div class="payload-grid">' + entries.map(function(pair) {
    var k = pair[0], v = pair[1], valHtml;
    if (typeof v === "boolean") {
      valHtml = '<span class="payload-val ' + (v ? "bool-true" : "bool-false") + '">' + v + '</span>';
    } else if (v && typeof v === "object" && depth < 2) {
      valHtml = formatPayload(v, depth + 1);
    } else {
      valHtml = '<span class="payload-val">' + (v === null ? "null" : String(v)) + '</span>';
    }
    return '<span class="payload-key">' + k + ':</span>' + valHtml;
  }).join("") + '</div>';
}

/* ═══════════════════════════════════════════════════════════════
   PART 4: GRAPH CREATION + RENDERING
   ═══════════════════════════════════════════════════════════════ */
// NOTE: All innerHTML in this file renders hardcoded data arrays (nodes, edges, flows).
// This is a local-only debugging tool, not a user-facing application.
function createNodeElements() {
  nodes.forEach(function(node) {
    var el = document.createElement("button");
    el.type = "button";
    el.className = "node";
    el.style.left = node.x + "px";
    el.style.top = node.y + "px";
    el.dataset.nodeId = node.id;
    el.setAttribute("aria-label", node.title);
    var titleDiv = document.createElement("div");
    titleDiv.className = "title";
    titleDiv.textContent = node.title;
    var metaDiv = document.createElement("div");
    metaDiv.className = "meta";
    metaDiv.textContent = node.subtitle;
    el.appendChild(titleDiv);
    el.appendChild(metaDiv);
    el.addEventListener("click", function() {
      state.selectedNodeId = node.id;
      state.selectedEdgeId = null;
      var hasState = node.stateMachine || node.policyTable;
      var hasData = node.dataModel || node.derivedFrom || node.retention || node.exposes || node.polling || node.notes || node.rules;
      state.detailTab = hasState ? "state" : (hasData ? "data" : "overview");
      openDetailPopover();
    });
    graphEl.appendChild(el);
  });
}

function createEdgeElements() {
  edges.forEach(function(edge) {
    var from = nodeCenter(byId(nodes, edge.from));
    var to = nodeCenter(byId(nodes, edge.to));
    var pathData = edgePath(from, to);
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", pathData);
    path.setAttribute("class", "edge");
    path.dataset.edgeId = edge.id;
    path.setAttribute("marker-end", "url(#arrow-future)");
    edgeLayer.appendChild(path);

    var hit = document.createElementNS("http://www.w3.org/2000/svg", "path");
    hit.setAttribute("d", pathData);
    hit.setAttribute("class", "edge-hit");
    hit.setAttribute("stroke", "transparent");
    hit.setAttribute("stroke-width", "14");
    hit.setAttribute("fill", "none");
    hit.dataset.edgeId = edge.id;
    hit.style.pointerEvents = "stroke";
    hit.addEventListener("click", function() {
      state.selectedEdgeId = edge.id;
      state.selectedNodeId = null;
      state.detailTab = "overview";
      openDetailPopover();
    });
    hit.addEventListener("mouseenter", function() {
      var label = graphEl.querySelector('.edge-label[data-edge-id="' + edge.id + '"]');
      if (label) label.classList.add("visible");
    });
    hit.addEventListener("mouseleave", function() {
      var label = graphEl.querySelector('.edge-label[data-edge-id="' + edge.id + '"]');
      if (label) {
        var activeEId = currentFlow().steps[state.stepIndex].edgeId;
        var hasSel = state.selectedNodeId || state.selectedEdgeId;
        var rEdges = new Set();
        if (state.selectedNodeId) edges.forEach(function(e) { if (e.from === state.selectedNodeId || e.to === state.selectedNodeId) rEdges.add(e.id); });
        else if (state.selectedEdgeId) rEdges.add(state.selectedEdgeId);
        if (edge.id !== activeEId && !(hasSel && rEdges.has(edge.id)) && edge.id !== state.selectedEdgeId) label.classList.remove("visible");
      }
    });
    edgeLayer.appendChild(hit);

    var mid = edgeMidpoint(from, to);
    var label = document.createElement("div");
    label.className = "edge-label";
    label.dataset.edgeId = edge.id;
    label.style.left = mid.x + "px";
    label.style.top = mid.y + "px";
    label.textContent = edge.label;
    graphEl.appendChild(label);

    if (edge.failureModes && edge.failureModes.length > 0) {
      path.classList.add("has-failure");
      var icon = document.createElement("div");
      icon.className = "edge-failure-icon";
      icon.dataset.edgeId = edge.id;
      icon.style.left = (mid.x + 12) + "px";
      icon.style.top = (mid.y + 14) + "px";
      icon.textContent = "\u26A0";
      var tooltip = document.createElement("div");
      tooltip.className = "edge-failure-tooltip";
      tooltip.innerHTML = edge.failureModes.map(function(fm, i) {
        return (i > 0 ? '<hr class="ft-separator">' : '') +
          '<div class="ft-scenario">' + fm.scenario + '</div>' +
          '<div class="ft-symptom">' + fm.symptom + '</div>' +
          '<div class="ft-recovery">' + (fm.recovery || fm.mitigation || '') + '</div>';
      }).join('');
      icon.appendChild(tooltip);
      graphEl.appendChild(icon);
    }
  });
}

function renderGraph() {
  var activeEdge = byId(edges, currentFlow().steps[state.stepIndex].edgeId);
  var activeNodes = new Set([activeEdge.from, activeEdge.to]);
  var hasSelection = state.selectedNodeId || state.selectedEdgeId;
  var relatedNodes = new Set();
  var relatedEdges = new Set();
  if (state.selectedNodeId) {
    relatedNodes.add(state.selectedNodeId);
    edges.forEach(function(e) { if (e.from === state.selectedNodeId || e.to === state.selectedNodeId) { relatedEdges.add(e.id); relatedNodes.add(e.from); relatedNodes.add(e.to); } });
  } else if (state.selectedEdgeId) {
    var selEdge = byId(edges, state.selectedEdgeId);
    if (selEdge) { relatedEdges.add(selEdge.id); relatedNodes.add(selEdge.from); relatedNodes.add(selEdge.to); }
  }
  document.querySelectorAll(".edge").forEach(function(path) {
    var edgeId = path.dataset.edgeId;
    var status = flowEdgeState(edgeId);
    path.classList.remove("done", "active", "selected", "dimmed");
    if (status === "done") { path.classList.add("done"); path.setAttribute("marker-end", "url(#arrow-done)"); }
    else if (status === "active") { path.classList.add("active"); path.setAttribute("marker-end", "url(#arrow-active)"); }
    else { path.setAttribute("marker-end", "url(#arrow-future)"); }
    if (state.selectedEdgeId === edgeId) path.classList.add("selected");
    if (hasSelection && !relatedEdges.has(edgeId) && status !== "active") path.classList.add("dimmed");
  });
  var activeEdgeId = currentFlow().steps[state.stepIndex].edgeId;
  document.querySelectorAll(".edge-label").forEach(function(label) {
    var eid = label.dataset.edgeId;
    label.classList.toggle("visible", eid === activeEdgeId || (hasSelection && relatedEdges.has(eid)) || eid === state.selectedEdgeId);
    label.classList.toggle("dimmed", hasSelection && !relatedEdges.has(eid) && eid !== activeEdgeId);
  });
  document.querySelectorAll(".edge-failure-icon").forEach(function(icon) { icon.style.display = "none"; });
  document.querySelectorAll(".node").forEach(function(nodeEl) {
    var nid = nodeEl.dataset.nodeId;
    nodeEl.classList.remove("active", "selected", "dimmed");
    if (activeNodes.has(nid)) nodeEl.classList.add("active");
    if (state.selectedNodeId === nid) nodeEl.classList.add("selected");
    if (hasSelection && !relatedNodes.has(nid) && !activeNodes.has(nid)) nodeEl.classList.add("dimmed");
  });
}

/* ═══════════════════════════════════════════════════════════════
   PART 5: MINIMAP
   ═══════════════════════════════════════════════════════════════ */
function initMinimap() {
  if (!graphWrapEl) return;
  var minimap = document.createElement("div");
  minimap.className = "minimap";
  var title = document.createElement("h4");
  title.textContent = "Canvas";
  minimap.appendChild(title);
  var canvasWrap = document.createElement("div");
  canvasWrap.style.position = "relative";
  var canvas = document.createElement("canvas");
  var canvasWidth = 200;
  var canvasHeight = Math.round(canvasWidth * (GRAPH_HEIGHT / GRAPH_WIDTH));
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
  canvasWrap.appendChild(canvas);
  var view = document.createElement("div");
  view.className = "minimap-view";
  canvasWrap.appendChild(view);
  minimap.appendChild(canvasWrap);
  graphWrapEl.parentElement.appendChild(minimap);
  controlState.minimap = minimap;
  controlState.minimapCanvas = canvas;
  controlState.minimapView = view;
  controlState.minimapScale = canvasWidth / GRAPH_WIDTH;
  canvas.addEventListener("click", function(event) {
    var rect = canvas.getBoundingClientRect();
    var x = (event.clientX - rect.left) / controlState.minimapScale;
    var y = (event.clientY - rect.top) / controlState.minimapScale;
    var mL = GRAPH_WIDTH - graphWrapEl.clientWidth;
    var mT = GRAPH_HEIGHT - graphWrapEl.clientHeight;
    graphWrapEl.scrollTo({ left: clamp(x - graphWrapEl.clientWidth/2, 0, Math.max(0,mL)), top: clamp(y - graphWrapEl.clientHeight/2, 0, Math.max(0,mT)), behavior: "smooth" });
  });
  graphWrapEl.addEventListener("scroll", updateMinimapView);
  window.addEventListener("resize", updateMinimapView);
}

function renderMinimap() {
  var canvas = controlState.minimapCanvas;
  if (!canvas) return;
  var ctx = canvas.getContext("2d");
  if (!ctx) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.scale(controlState.minimapScale, controlState.minimapScale);
  edges.forEach(function(edge) {
    var f = nodeCenter(byId(nodes, edge.from)), t = nodeCenter(byId(nodes, edge.to));
    var s = flowEdgeState(edge.id);
    ctx.strokeStyle = (s === "active" || s === "done") ? "#00c8ff" : "#302010";
    ctx.lineWidth = s === "active" ? 2 : 1;
    ctx.beginPath(); ctx.moveTo(f.x, f.y); ctx.lineTo(t.x, t.y); ctx.stroke();
  });
  nodes.forEach(function(node) {
    ctx.fillStyle = node.id === state.selectedNodeId ? "#ffb000" : "#140f04";
    ctx.fillRect(node.x, node.y, NODE_W, NODE_H);
    ctx.strokeStyle = "#4a3510";
    ctx.strokeRect(node.x, node.y, NODE_W, NODE_H);
  });
  ctx.restore();
  updateMinimapView();
}

function updateMinimapView() {
  if (!graphWrapEl) return;
  var v = controlState.minimapView, c = controlState.minimapCanvas;
  if (!v || !c) return;
  var s = controlState.minimapScale;
  v.style.width = (graphWrapEl.clientWidth * s) + "px";
  v.style.height = (graphWrapEl.clientHeight * s) + "px";
  v.style.left = (c.offsetLeft + graphWrapEl.scrollLeft * s) + "px";
  v.style.top = (c.offsetTop + graphWrapEl.scrollTop * s) + "px";
}

/* ═══════════════════════════════════════════════════════════════
   PART 6: DETAIL RENDERING HELPERS
   ═══════════════════════════════════════════════════════════════ */
function renderFileDetails(files) {
  return files.map(function(file) {
    var base = file.split("/").pop();
    return '<details class="file-detail"><summary>' + base + '</summary><div class="file-path">' + file + '</div></details>';
  }).join("");
}
function renderListSection(title, items) {
  if (!items || items.length === 0) return "";
  return '<div class="detail-section"><h4>' + title + '</h4><ul class="detail-list">' + items.map(function(item) { return '<li>' + item + '</li>'; }).join("") + '</ul></div>';
}
function renderDataModel(tables) {
  if (!tables || tables.length === 0) return "";
  var rows = tables.map(function(table) {
    return '<tr><td><span class="table-name">' + table.name + '</span><span class="table-desc">' + (table.description || "") + '</span></td><td>' + (table.columns ? table.columns.join(", ") : "") + '</td></tr>';
  }).join("");
  return '<div class="detail-section"><h4>Tables</h4><table class="data-table"><thead><tr><th>Table</th><th>Columns</th></tr></thead><tbody>' + rows + '</tbody></table></div>';
}
function renderNodeData(node) {
  return [renderDataModel(node.dataModel), renderListSection("Snapshots / APIs", node.exposes), renderListSection("Derived from", node.derivedFrom), renderListSection("Session rules", node.rules), renderListSection("Polling / cadence", node.polling), renderListSection("Retention / pruning", node.retention), renderListSection("Notes", node.notes)].filter(Boolean).join("");
}
function renderStateMachine(sm) {
  if (!sm) return "";
  var stateColors = { Working: "working", Ready: "ready", Idle: "idle", Compacting: "compacting", Waiting: "waiting" };
  var chips = sm.states.map(function(s) { return '<span class="state-chip ' + (stateColors[s] || "") + '">' + s + '</span>'; }).join("");
  var rows = sm.transitions.map(function(t) { return '<tr><td>' + t.from + '</td><td>' + t.trigger + '</td><td>' + (t.to || "delete") + '</td><td>' + (t.condition || "") + '</td></tr>'; }).join("");
  return '<div style="margin-bottom:6px;font-size:12px;color:var(--text);font-weight:600;">' + sm.name + '</div><div class="state-diagram">' + chips + '</div><table class="transition-table"><thead><tr><th>From</th><th>Trigger</th><th>To</th><th>Condition</th></tr></thead><tbody>' + rows + '</tbody></table>';
}
function renderPolicyTable(pt) {
  if (!pt) return "";
  var rules = pt.rules.map(function(r) {
    var statusCls = r.condition ? "conditional" : (r.enabled ? "enabled" : "disabled");
    var statusText = r.condition ? "conditional" : (r.enabled ? "active" : "off");
    return '<li class="policy-rule"><span class="policy-rank">#' + (r.rank + 1) + '</span><span class="policy-desc">' + r.description + '</span><span class="policy-status ' + statusCls + '">' + statusText + '</span></li>';
  }).join("");
  var ctx = pt.context ? Object.entries(pt.context).map(function(pair) { return '<span style="font-size:10px;color:var(--muted);">' + pair[0] + ': ' + pair[1] + '</span>'; }).join(" ") : "";
  return '<div style="margin-bottom:6px;font-size:12px;color:var(--text);font-weight:600;">' + pt.name + '</div>' + (ctx ? '<div style="margin-bottom:6px;">' + ctx + '</div>' : "") + '<ol class="policy-rules">' + rules + '</ol>';
}
function renderFailureModes(fms) {
  if (!fms || fms.length === 0) return "";
  return '<div class="failure-indicator">Known failure modes (' + fms.length + ')</div><ul class="failure-list">' + fms.map(function(f) {
    return '<li class="failure-item"><div class="scenario">' + f.scenario + '</div><div class="symptom">' + f.symptom + '</div><div class="recovery">' + (f.recovery || f.mitigation || "") + '</div></li>';
  }).join("") + '</ul>';
}

/* ═══════════════════════════════════════════════════════════════
   PART 7: DETAIL POPOVER
   ═══════════════════════════════════════════════════════════════ */
function openDetailPopover() {
  state.detailPopoverOpen = true;
  var overlay = document.getElementById("detail-popover");
  var panel = document.getElementById("detail-popover-panel");
  renderDetailPopover(panel);
  overlay.style.display = "flex";
}
function closeDetailPopover() {
  state.detailPopoverOpen = false;
  document.getElementById("detail-popover").style.display = "none";
  state.selectedNodeId = null;
  state.selectedEdgeId = null;
  renderGraph();
  renderMinimap();
}
function switchDetailTab(tabName) {
  state.detailTab = tabName;
  document.querySelectorAll("#detail-popover-panel .detail-tab").forEach(function(t) { t.classList.toggle("active", t.dataset.tab === tabName); });
  document.querySelectorAll("#detail-popover-panel .detail-tab-content").forEach(function(c) { c.classList.toggle("active", c.dataset.tab === tabName); });
}

function renderDetailPopover(panel) {
  if (state.selectedNodeId) {
    var node = byId(nodes, state.selectedNodeId);
    var related = edges.filter(function(e) { return e.from === node.id || e.to === node.id; });
    var hasState = node.stateMachine || node.policyTable;
    var hasData = node.dataModel || node.derivedFrom || node.retention || node.exposes || node.polling || node.notes || node.rules;
    var hasFailures = node.failureModes && node.failureModes.length > 0;
    var dt = state.detailTab || "overview";
    var tabsArr = [["overview", "Overview"]];
    if (hasData) tabsArr.push(["data", "Data"]);
    if (hasState) tabsArr.push(["state", "State"]);
    tabsArr.push(["edges", "Edges"]);
    if (hasFailures) tabsArr.push(["failures", "Failures"]);
    var tabBtns = tabsArr.map(function(t) { return '<button class="detail-tab ' + (dt === t[0] ? "active" : "") + '" data-tab="' + t[0] + '">' + t[1] + '</button>'; }).join("");
    var overviewHtml = '<p><strong>' + node.title + '</strong></p><p>' + node.subtitle + '</p>' + (node.purpose ? '<p><strong>Purpose</strong> ' + node.purpose + '</p>' : "") + '<p><code>layer</code> ' + (node.layer || "unknown") + '</p><p><code>tag</code> ' + node.tag + '</p>';
    var dataHtml = hasData ? renderNodeData(node) : "";
    var stateHtml = "";
    if (node.stateMachine) stateHtml += renderStateMachine(node.stateMachine);
    if (node.policyTable) stateHtml += renderPolicyTable(node.policyTable);
    var edgesHtml = '<p style="color:var(--muted);font-size:11px;margin-bottom:8px;">Connected interfaces: ' + related.length + '</p><div class="files">' + related.map(function(e) {
      var bt = e.boundaryType || "in-process";
      return '<div class="file"><span class="boundary-badge ' + bt + '">' + bt.replace("-", " ") + '</span> ' + e.name + '</div>';
    }).join("") + '</div>';
    var failHtml = hasFailures ? renderFailureModes(node.failureModes) : "";
    var panels = ['<div class="detail-tab-content ' + (dt === "overview" ? "active" : "") + '" data-tab="overview">' + overviewHtml + '</div>'];
    if (hasData) panels.push('<div class="detail-tab-content ' + (dt === "data" ? "active" : "") + '" data-tab="data">' + dataHtml + '</div>');
    if (hasState) panels.push('<div class="detail-tab-content ' + (dt === "state" ? "active" : "") + '" data-tab="state">' + stateHtml + '</div>');
    panels.push('<div class="detail-tab-content ' + (dt === "edges" ? "active" : "") + '" data-tab="edges">' + edgesHtml + '</div>');
    if (hasFailures) panels.push('<div class="detail-tab-content ' + (dt === "failures" ? "active" : "") + '" data-tab="failures">' + failHtml + '</div>');
    panel.innerHTML = '<h3>Node: ' + node.title + '</h3><div class="detail-tabs">' + tabBtns + '</div>' + panels.join("");
    panel.querySelectorAll(".detail-tab").forEach(function(tab) { tab.addEventListener("click", function() { switchDetailTab(tab.dataset.tab); }); });
    return;
  }
  if (state.selectedEdgeId) {
    var edge = byId(edges, state.selectedEdgeId);
    var confidence = edge.confidence || "deterministic";
    var bt = edge.boundaryType || "in-process";
    var hasF = edge.failureModes && edge.failureModes.length > 0;
    var dt2 = state.detailTab || "overview";
    var tabsArr2 = [["overview", "Overview"], ["data", "Data"]];
    if (hasF) tabsArr2.push(["failures", "Failures"]);
    tabsArr2.push(["files", "Files"]);
    var tabBtns2 = tabsArr2.map(function(t) { return '<button class="detail-tab ' + (dt2 === t[0] ? "active" : "") + '" data-tab="' + t[0] + '">' + t[1] + '</button>'; }).join("");
    var oHtml = '<p><strong>' + edge.name + '</strong></p><div style="display:flex;flex-wrap:wrap;gap:6px;margin:8px 0;"><span class="boundary-badge ' + bt + '">' + bt.replace("-"," ") + '</span><span class="latency-badge">' + (edge.latencyClass||"") + '</span><span class="latency-badge">' + (edge.directionality||"").replace("-"," ") + '</span></div><div class="confidence"><span class="confidence-badge confidence-' + confidence + '">' + confidence.replace("-"," ") + '</span>' + (edge.confidenceNote ? ' <span class="confidence-note">' + edge.confidenceNote + '</span>' : "") + '</div>';
    var dHtml = '<p><code>boundary</code> ' + edge.boundary + '</p><p><code>request</code> ' + edge.request + '</p><p><code>response</code> ' + edge.response + '</p>';
    var fHtml = hasF ? renderFailureModes(edge.failureModes) : "";
    var filesHtml = '<div class="files">' + renderFileDetails(edge.files) + '</div>';
    var panels2 = ['<div class="detail-tab-content ' + (dt2==="overview"?"active":"") + '" data-tab="overview">' + oHtml + '</div>', '<div class="detail-tab-content ' + (dt2==="data"?"active":"") + '" data-tab="data">' + dHtml + '</div>'];
    if (hasF) panels2.push('<div class="detail-tab-content ' + (dt2==="failures"?"active":"") + '" data-tab="failures">' + fHtml + '</div>');
    panels2.push('<div class="detail-tab-content ' + (dt2==="files"?"active":"") + '" data-tab="files">' + filesHtml + '</div>');
    panel.innerHTML = '<h3>Interface Detail</h3><div class="detail-tabs">' + tabBtns2 + '</div>' + panels2.join("");
    panel.querySelectorAll(".detail-tab").forEach(function(tab) { tab.addEventListener("click", function() { switchDetailTab(tab.dataset.tab); }); });
  }
}

/* ═══════════════════════════════════════════════════════════════
   PART 8: LEARN TAB CONTROLS + FLOW
   ═══════════════════════════════════════════════════════════════ */
function initLearnControls() {
  var el = document.getElementById("learn-controls");
  el.innerHTML = '<div class="control-group" id="flow-buttons"></div><div class="spacer"></div><div class="control-group"><button class="ctrl" id="step-back" type="button">\u25C2 Back</button><button class="ctrl" id="step-forward" type="button">Fwd \u25B8</button><button class="ctrl" id="play-pause" type="button">\u25B6 Play</button><span id="step-counter" style="font-size:11px;color:var(--muted);"></span></div>';
  var flowBtnsEl = document.getElementById("flow-buttons");
  flows.forEach(function(flow, index) {
    var btn = document.createElement("button");
    btn.type = "button";
    btn.className = "flow-btn";
    btn.dataset.flow = flow.id;
    btn.textContent = flow.name;
    btn.addEventListener("click", function() { setFlow(flow.id); });
    flowBtnsEl.appendChild(btn);
    controlState.flowButtons.set(flow.id, btn);
  });
  controlState.stepBack = document.getElementById("step-back");
  controlState.stepForward = document.getElementById("step-forward");
  controlState.playPause = document.getElementById("play-pause");
  controlState.stepCounter = document.getElementById("step-counter");
  controlState.stepBack.addEventListener("click", stepBack);
  controlState.stepForward.addEventListener("click", stepForward);
  controlState.playPause.addEventListener("click", togglePlay);
}

function renderLearnControls() {
  controlState.flowButtons.forEach(function(btn, flowId) {
    btn.classList.toggle("active", flowId === state.flowId);
  });
  var flow = currentFlow();
  var total = flow.steps.length;
  controlState.stepBack.disabled = state.stepIndex === 0;
  controlState.stepForward.disabled = state.stepIndex >= total - 1;
  controlState.playPause.textContent = state.playing ? "\u23F8 Pause" : "\u25B6 Play";
  if (controlState.stepCounter) controlState.stepCounter.textContent = (state.stepIndex + 1) + " / " + total;
}

function renderFlowPanel() {
  var flow = currentFlow();
  flowTitleEl.textContent = flow.name;
  stepListEl.innerHTML = flow.steps.map(function(step, idx) {
    var edge = byId(edges, step.edgeId);
    var cls = idx < state.stepIndex ? "done" : idx === state.stepIndex ? "active" : "future";
    return '<li><button class="step-item ' + cls + '" data-step="' + idx + '" type="button"' + (idx === state.stepIndex ? ' aria-current="step"' : '') + '><strong>' + (idx+1) + '. ' + edge.name + '</strong></button></li>';
  }).join("");
  stepListEl.querySelectorAll(".step-item").forEach(function(button) {
    button.addEventListener("click", function() {
      state.stepIndex = Number(button.dataset.step);
      pushTrace("jump", byId(edges, flow.steps[state.stepIndex].edgeId));
      render();
    });
  });
}

function pushTrace(action, edge) {
  var stamp = new Date().toLocaleTimeString();
  var flow = currentFlow();
  var kind = classifyTraceKind({ action: action }, edge);
  state.trace.unshift({ time: stamp, text: "[" + flow.id + "] " + action + ": " + edge.name, detail: edge.request + " -> " + edge.response, kind: kind });
  state.trace = state.trace.slice(0, 60);
}

/* ═══════════════════════════════════════════════════════════════
   PART 9: FLOW NAVIGATION
   ═══════════════════════════════════════════════════════════════ */
function setFlow(flowId, options) {
  if (!options) options = {};
  var stepIndex = options.stepIndex || 0;
  var flow = byId(flows, flowId);
  if (!flow) return;
  stopPlay();
  state.flowId = flowId;
  state.stepIndex = clamp(stepIndex, 0, flow.steps.length - 1);
  if (options.clearSelection !== false) { state.selectedNodeId = null; state.selectedEdgeId = null; }
  state.trace = [];
  pushTrace("start", byId(edges, flow.steps[0].edgeId));
  render();
}

function stepForward() {
  var flow = currentFlow();
  if (state.stepIndex >= flow.steps.length - 1) { stopPlay(); return; }
  state.stepIndex += 1;
  pushTrace("step", byId(edges, flow.steps[state.stepIndex].edgeId));
  render();
}
function stepBack() {
  if (state.stepIndex === 0) return;
  state.stepIndex -= 1;
  pushTrace("back", byId(edges, currentFlow().steps[state.stepIndex].edgeId));
  render();
}
function resetFlow() {
  stopPlay();
  state.stepIndex = 0;
  state.selectedNodeId = null;
  state.selectedEdgeId = null;
  state.trace = [];
  pushTrace("reset", byId(edges, currentFlow().steps[0].edgeId));
  render();
}
function togglePlay() { if (state.playing) stopPlay(); else startPlay(); render(); }
function startPlay() {
  if (state.playing) return;
  var interval = window.matchMedia("(prefers-reduced-motion: reduce)").matches ? 2400 : 1400;
  state.playing = true;
  state.timer = setInterval(function() {
    if (state.stepIndex >= currentFlow().steps.length - 1) { stopPlay(); render(); return; }
    stepForward();
  }, interval);
}
function stopPlay() {
  state.playing = false;
  if (state.timer) { clearInterval(state.timer); state.timer = null; }
}

/* ═══════════════════════════════════════════════════════════════
   PART 10: LIVE TAB — SNAPSHOT + TIMELINE
   ═══════════════════════════════════════════════════════════════ */
function renderLiveState(data) {
  var sessionsEl = document.getElementById("kpi-sessions");
  var projectEl = document.getElementById("kpi-project");
  var shellsEl = document.getElementById("kpi-shells");
  var daemonEl = document.getElementById("kpi-daemon");
  var sectionsEl = document.getElementById("snapshot-sections");
  if (!data || !data.ok) {
    sessionsEl.textContent = "--";
    projectEl.textContent = "--";
    shellsEl.textContent = "--";
    daemonEl.textContent = data ? "err" : "--";
    daemonEl.className = "kpi-value unhealthy";
    sectionsEl.innerHTML = '<div style="color:var(--muted);font-size:11px;padding:8px;">No snapshot data.</div>';
    return;
  }
  var sessions = Array.isArray(data.sessions) ? data.sessions : [];
  var projects = Array.isArray(data.project_states) ? data.project_states : [];
  var shellsMap = data.shell_state && data.shell_state.shells ? data.shell_state.shells : {};
  var shells = Object.entries(shellsMap).map(function(pair) { return Object.assign({ pid: pair[0] }, pair[1]); });
  var health = data.health && typeof data.health === "object" ? data.health : null;
  sessionsEl.textContent = sessions.length;
  var activeProj = projects.find(function(p) { return p.state === "Active"; });
  projectEl.textContent = activeProj ? (activeProj.project_path || "").split("/").pop() : (projects.length ? projects[0].project_path.split("/").pop() : "--");
  shellsEl.textContent = shells.length;
  var daemonHealthy = Boolean(health && String(health.status || "").toLowerCase() === "ok");
  daemonEl.textContent = daemonHealthy ? "OK" : (health && health.status ? String(health.status).toUpperCase() : "UNK");
  daemonEl.className = "kpi-value " + (daemonHealthy ? "healthy" : "unhealthy");

  var html = '';
  // Sessions section
  html += '<div class="data-section-header">Sessions (' + sessions.length + ')</div><div class="data-section-body">';
  sessions.slice(0, 10).forEach(function(s) {
    html += '<div class="snapshot-item">' + formatPayload({ state: s.state, session_id: (s.session_id || "").slice(0,8), cwd: s.cwd || s.project_path || "--" }) + '</div>';
  });
  html += '</div>';
  // Projects section
  html += '<div class="data-section-header">Projects (' + projects.length + ')</div><div class="data-section-body">';
  projects.slice(0, 10).forEach(function(p) {
    html += '<div class="snapshot-item">' + formatPayload({ state: p.state, path: p.project_path || "--", sessions: p.session_count || 0, active: p.active_count || 0 }) + '</div>';
  });
  html += '</div>';
  // Shells section
  html += '<div class="data-section-header collapsed">Shells (' + shells.length + ')</div><div class="data-section-body">';
  shells.slice(0, 15).forEach(function(s) {
    html += '<div class="snapshot-item">' + formatPayload({ pid: s.pid, cwd: s.cwd || "--", parent: s.parent_app || s.parentApp || "--" }) + '</div>';
  });
  html += '</div>';
  // Daemon health + reconcile telemetry
  if (health) {
    var reconcile = health.dead_session_reconcile && typeof health.dead_session_reconcile === "object"
      ? health.dead_session_reconcile
      : {};
    html += '<div class="data-section-header collapsed">Daemon Health</div><div class="data-section-body">';
    html += '<div class="snapshot-item">' + formatPayload({
      status: health.status || "--",
      pid: health.pid || "--",
      version: health.version || "--",
      protocol_version: health.protocol_version || "--",
      reconcile_interval_secs: health.dead_session_reconcile_interval_secs || "--"
    }) + '</div>';
    Object.keys(reconcile).sort().forEach(function(source) {
      var metrics = reconcile[source] || {};
      html += '<div class="snapshot-item">' + formatPayload({
        source: source,
        runs: metrics.runs || 0,
        repaired_sessions: metrics.repaired_sessions || 0,
        last_run: metrics.last_run_at ? relativeTime(metrics.last_run_at) : "never",
        last_repair: metrics.last_repair_at ? relativeTime(metrics.last_repair_at) : "never"
      }) + '</div>';
    });
    html += '</div>';
  }
  sectionsEl.innerHTML = html;
  // Wire up collapsible headers
  sectionsEl.querySelectorAll(".data-section-header").forEach(function(header) {
    header.addEventListener("click", function() { header.classList.toggle("collapsed"); });
  });
}

async function fetchSnapshot() {
  if (!state.snapshotUrl) return;
  try {
    var response = await fetch(state.snapshotUrl, { cache: "no-store" });
    if (!response.ok) throw new Error("HTTP " + response.status);
    var data = await response.json();
    state.snapshotData = data;
    state.snapshotError = null;
    state.snapshotLastSuccess = Date.now();
    renderLiveState(data);
  } catch (error) {
    state.snapshotError = error ? String(error) : "fetch failed";
    renderLiveState(null);
  }
}

function stopSnapshotPolling() { if (state.snapshotTimer) { clearInterval(state.snapshotTimer); state.snapshotTimer = null; } }
function startSnapshotPolling() { stopSnapshotPolling(); if (!state.snapshotAuto) return; state.snapshotTimer = setInterval(fetchSnapshot, 2000); }

/* ═══════════════════════════════════════════════════════════════
   PART 11: UNIFIED TIMELINE
   ═══════════════════════════════════════════════════════════════ */
function mergeIntoUnifiedTimeline(event, sourceHint) {
  var id = event.id || event.event_id || (event.type + "_" + (event.timestamp || Date.now()) + "_" + Math.random().toString(36).slice(2,6));
  if (state.unifiedEventIds.has(id)) return;
  state.unifiedEventIds.add(id);
  var source = sourceHint || classifyEventSource(event);
  var name = event.name || event.type || event.event || "event";
  var ts = event.received_at || event.timestamp || event.time || new Date().toISOString();

  // Coalesce: if same event name appeared within last 30s, update in place
  var now = Date.now();
  var COALESCE_WINDOW = 30000;
  var existing = state.unifiedEvents.find(function(e) {
    return e.name === name && (now - new Date(e.timestamp).getTime()) < COALESCE_WINDOW;
  });
  if (existing) {
    existing.count = (existing.count || 1) + 1;
    existing.timestamp = ts;
    existing.detail = event.message || event.detail || event.summary || existing.detail;
    existing.payload = event.payload || existing.payload;
    if (event.decision) state.lastDecision = event.decision;
    renderUnifiedTimeline();
    renderActivationTrace();
    return;
  }

  var unified = {
    id: id,
    timestamp: ts,
    source: source,
    name: name,
    detail: event.message || event.detail || event.summary || "",
    payload: event.payload || null,
    count: 1
  };
  state.unifiedEvents.unshift(unified);
  if (state.unifiedEvents.length > 200) {
    var removed = state.unifiedEvents.pop();
    if (removed) state.unifiedEventIds.delete(removed.id);
  }
  if (event.decision) state.lastDecision = event.decision;
  renderUnifiedTimeline();
  renderActivationTrace();
}

function renderUnifiedTimeline() {
  var container = document.getElementById("timeline-events");
  if (!container) return;
  var events = state.unifiedEvents;
  var filter = state.timelineFilter.toLowerCase();
  var sourceFilter = state.timelineSourceFilter;
  var filtered = events.filter(function(ev) {
    if (sourceFilter !== "all" && ev.source !== sourceFilter) return false;
    if (filter && (ev.name + " " + ev.detail + " " + JSON.stringify(ev.payload)).toLowerCase().indexOf(filter) === -1) return false;
    return true;
  });
  if (filtered.length === 0) {
    container.innerHTML = '<div class="timeline-empty">No events' + (filter || sourceFilter !== "all" ? " matching filter" : " yet") + '.</div>';
    return;
  }
  // NOTE: Standalone local debug tool — all content from app telemetry, not user input
  container.innerHTML = filtered.slice(0, 50).map(function(ev) {
    var ts = ev.timestamp;
    try { ts = new Date(ev.timestamp).toLocaleTimeString(); } catch(e) {}
    var payloadHtml = ev.payload ? '<div class="event-payload">' + formatPayload(ev.payload) + '</div>' : '';
    var isCoalesced = ev.count > 1;
    var countBadge = isCoalesced ? '<span class="event-count">\u00d7 ' + ev.count + '</span>' : '';
    var cls = 'timeline-event source-' + ev.source + (isCoalesced ? ' coalesced' : '');
    return '<div class="' + cls + '"><div class="event-header"><span class="event-name">' + ev.name + countBadge + '</span><span class="event-time">' + ts + '</span></div>' + (ev.detail ? '<div class="event-detail">' + ev.detail + '</div>' : '') + payloadHtml + '</div>';
  }).join("");
}

function relativeTime(isoString) {
  if (!isoString) return "\u2014";
  try {
    var diff = Date.now() - new Date(isoString).getTime();
    if (diff < 0) return "just now";
    var sec = Math.floor(diff / 1000);
    if (sec < 5) return "just now";
    if (sec < 60) return sec + "s ago";
    var min = Math.floor(sec / 60);
    if (min < 60) return min + "m ago";
    var hr = Math.floor(min / 60);
    if (hr < 24) return hr + "h ago";
    var days = Math.floor(hr / 24);
    return days + "d ago";
  } catch(e) { return "\u2014"; }
}

function truncateCwd(path) {
  if (!path) return "\u2014";
  var home = "/Users/";
  var idx = path.indexOf(home);
  if (idx === 0) {
    var afterHome = path.substring(home.length);
    var slashIdx = afterHome.indexOf("/");
    if (slashIdx !== -1) path = "~" + afterHome.substring(slashIdx);
  }
  return path;
}

function renderActivationTrace() {
  // NOTE: Local-only debug tool rendering daemon telemetry, not user input
  var container = document.getElementById("activation-trace-section");
  if (!container) return;
  var decision = state.lastDecision;
  if (!decision) { container.textContent = ""; return; }
  var candidates = decision.candidates || [];
  var selectedPid = decision.selected_pid || decision.selectedPid;
  var outcome = decision.outcome || (decision.fallback ? "fallback" : (selectedPid ? "primary" : "none"));

  var frag = document.createDocumentFragment();
  var section = document.createElement("div");
  section.className = "trace-section";

  /* ── Header: outcome + action summary ── */
  var header = document.createElement("div");
  header.className = "trace-header";
  var h3 = document.createElement("h3");
  h3.textContent = "Activation Trace";
  header.appendChild(h3);
  var outBadge = document.createElement("span");
  outBadge.className = "trace-outcome " + outcome;
  outBadge.textContent = outcome;
  header.appendChild(outBadge);
  if (decision.primary) {
    var actionSpan = document.createElement("span");
    actionSpan.className = "trace-action";
    var actionLabel = document.createElement("strong");
    actionLabel.textContent = "action ";
    actionSpan.appendChild(actionLabel);
    actionSpan.appendChild(document.createTextNode((decision.primary.action || "\u2014") + " \u2192 " + (decision.primary.target || "\u2014")));
    header.appendChild(actionSpan);
  }
  section.appendChild(header);

  /* ── Policy config pills ── */
  var preferTmux = decision.prefer_tmux || decision.preferTmux || false;
  var policyOrder = decision.policy_order || decision.policyOrder || [];
  if (preferTmux || policyOrder.length > 0) {
    var cfgDiv = document.createElement("div");
    cfgDiv.className = "trace-config";
    var tmuxPill = document.createElement("span");
    tmuxPill.className = "trace-config-pill" + (preferTmux ? " active" : "");
    tmuxPill.textContent = "tmux_prefer: " + (preferTmux ? "on" : "off");
    cfgDiv.appendChild(tmuxPill);
    policyOrder.forEach(function(p) {
      var pill = document.createElement("span");
      pill.className = "trace-config-pill";
      pill.textContent = p;
      cfgDiv.appendChild(pill);
    });
    section.appendChild(cfgDiv);
  }

  /* ── Candidate grid ── */
  if (candidates.length > 0) {
    var sorted = candidates.slice().sort(function(a, b) {
      var aWin = (a.selected || a.is_selected || (selectedPid != null && a.pid === selectedPid)) ? 0 : 1;
      var bWin = (b.selected || b.is_selected || (selectedPid != null && b.pid === selectedPid)) ? 0 : 1;
      if (aWin !== bWin) return aWin - bWin;
      return (a.match_rank || 99) - (b.match_rank || 99);
    });

    var grid = document.createElement("div");
    grid.className = "trace-grid";

    /* Column headers */
    var headRow = document.createElement("div");
    headRow.className = "trace-grid-head";
    ["PID", "Match", "CWD", "Parent", "Live", "Age", "Tmux"].forEach(function(label) {
      var col = document.createElement("span");
      col.textContent = label;
      headRow.appendChild(col);
    });
    grid.appendChild(headRow);

    sorted.forEach(function(c, idx) {
      var isSelected = c.selected || c.is_selected || (selectedPid != null && c.pid === selectedPid);
      var match = c.match || c.match_type || c.path_match || "none";
      var live = c.live != null ? c.live : (c.is_live != null ? c.is_live : c.isAlive);
      var isAlive = live === true || live === 1;
      var parentApp = c.parent || c.parent_app || "\u2014";
      var hasTmux = c.has_tmux || c.hasTmux || false;
      var updatedAt = c.updated_at || c.updatedAt || "";
      var cwd = c.cwd || "\u2014";
      var rankArr = Array.isArray(c.rank_key) ? c.rank_key : (Array.isArray(c.rank) ? c.rank : (Array.isArray(c.rankKey) ? c.rankKey : []));

      var row = document.createElement("div");
      row.className = "trace-row" + (isSelected ? " winner" : "") + (!isAlive ? " dead" : "");

      /* PID */
      var colPid = document.createElement("span");
      colPid.className = "trace-col-pid";
      colPid.textContent = c.pid || "\u2014";
      if (isSelected) {
        var selBadge = document.createElement("span");
        selBadge.className = "trace-selected-badge";
        selBadge.textContent = "SEL";
        colPid.appendChild(selBadge);
      }
      row.appendChild(colPid);

      /* Match */
      var colMatch = document.createElement("span");
      colMatch.className = "trace-col-match " + match;
      colMatch.textContent = match;
      row.appendChild(colMatch);

      /* CWD */
      var colCwd = document.createElement("span");
      colCwd.className = "trace-col-cwd";
      colCwd.title = cwd;
      colCwd.textContent = truncateCwd(cwd);
      row.appendChild(colCwd);

      /* Parent */
      var colParent = document.createElement("span");
      colParent.className = "trace-col-parent";
      colParent.textContent = parentApp;
      row.appendChild(colParent);

      /* Live dot */
      var colLive = document.createElement("span");
      colLive.className = "trace-col-live";
      var dot = document.createElement("span");
      dot.className = "trace-dot " + (isAlive ? "alive" : "dead");
      colLive.appendChild(dot);
      row.appendChild(colLive);

      /* Age */
      var colAge = document.createElement("span");
      colAge.className = "trace-col-age";
      colAge.textContent = relativeTime(updatedAt);
      row.appendChild(colAge);

      /* Tmux */
      var colTmux = document.createElement("span");
      colTmux.className = "trace-col-tmux";
      colTmux.textContent = hasTmux ? "\u2713" : "\u2014";
      row.appendChild(colTmux);

      grid.appendChild(row);

      /* Rank breakdown (expandable) */
      if (rankArr.length > 0) {
        var rankDiv = document.createElement("div");
        rankDiv.style.cssText = "padding: 0 6px;";
        var toggleBtn = document.createElement("button");
        toggleBtn.className = "rank-toggle";
        toggleBtn.textContent = "\u25B8 rank breakdown";
        var detailDiv = document.createElement("div");
        detailDiv.className = "rank-detail";
        rankArr.forEach(function(step, i) {
          var stepSpan = document.createElement("span");
          stepSpan.className = "rank-step";
          /* Shorten updated_at ISO timestamps to relative time */
          var display = step;
          if (step.indexOf("updated_at=") === 0) {
            var ts = step.substring(11);
            display = "age=" + relativeTime(ts);
          }
          stepSpan.textContent = display;
          stepSpan.title = step;
          detailDiv.appendChild(stepSpan);
          if (i < rankArr.length - 1) {
            var arrow = document.createElement("span");
            arrow.className = "rank-arrow";
            arrow.textContent = "\u2192";
            detailDiv.appendChild(arrow);
          }
        });
        toggleBtn.addEventListener("click", function() {
          var open = detailDiv.classList.toggle("open");
          toggleBtn.textContent = (open ? "\u25BE" : "\u25B8") + " rank breakdown";
        });
        rankDiv.appendChild(toggleBtn);
        rankDiv.appendChild(detailDiv);
        grid.appendChild(rankDiv);
      }
    });

    section.appendChild(grid);
  } else {
    var emptyDiv = document.createElement("div");
    emptyDiv.style.cssText = "font-size:11px;color:var(--muted);padding:8px 0;";
    emptyDiv.textContent = "No candidates in trace";
    section.appendChild(emptyDiv);
  }

  frag.appendChild(section);
  container.textContent = "";
  container.appendChild(frag);
}

/* Telemetry SSE + polling */
function connectTelemetrySSE() {
  if (state.telemetrySseSource) return;
  var url = state.telemetryUrl.replace(/\/telemetry$/, "/telemetry-stream");
  try {
    var source = new EventSource(url);
    state.telemetrySseSource = source;
    source.onmessage = function(event) {
      try {
        var data = JSON.parse(event.data);
        mergeIntoUnifiedTimeline(data, classifyEventSource(data));
      } catch(e) {}
    };
    source.onerror = function() { source.close(); state.telemetrySseSource = null; };
  } catch(e) { state.telemetrySseSource = null; }
}
function disconnectTelemetrySSE() {
  if (state.telemetrySseSource) { state.telemetrySseSource.close(); state.telemetrySseSource = null; }
}

async function fetchTelemetry() {
  if (!state.telemetryUrl) return;
  try {
    var response = await fetch(state.telemetryUrl + "?limit=50", { cache: "no-store" });
    if (!response.ok) return;
    var data = await response.json();
    var events = data && data.events ? data.events : [];
    events.forEach(function(ev) { mergeIntoUnifiedTimeline(ev, classifyEventSource(ev)); });
  } catch(e) {}
}
function stopTelemetryPolling() { if (state.telemetryTimer) { clearInterval(state.telemetryTimer); state.telemetryTimer = null; } }
function startTelemetryPolling() { stopTelemetryPolling(); if (!state.telemetryAuto) return; state.telemetryTimer = setInterval(fetchTelemetry, 3000); }

/* ═══════════════════════════════════════════════════════════════
   PART 12: LIVE CONNECTION (SSE/WS for activation trace)
   ═══════════════════════════════════════════════════════════════ */
function disconnectLive() {
  if (state.liveSource) { state.liveSource.close(); }
  state.liveSource = null;
  state.liveTransport = null;
  state.liveConnected = false;
  state.liveError = null;
}

function connectLive() {
  disconnectLive();
  var url = state.liveUrl;
  if (!url) { state.liveError = "missing URL"; return; }
  var statusEl = document.getElementById("live-status");
  if (url.startsWith("ws")) {
    var ws = new WebSocket(url);
    state.liveTransport = "ws";
    state.liveSource = ws;
    ws.onopen = function() { state.liveConnected = true; if (statusEl) statusEl.textContent = "Connected (ws)"; };
    ws.onmessage = function(event) { handleLivePayload(event.data); };
    ws.onerror = function() { state.liveError = "ws error"; state.liveConnected = false; if (statusEl) statusEl.textContent = "Error"; };
    ws.onclose = function() { state.liveConnected = false; if (statusEl) statusEl.textContent = "Disconnected"; };
    return;
  }
  try {
    var source = new EventSource(url);
    state.liveTransport = "sse";
    state.liveSource = source;
    source.onopen = function() { state.liveConnected = true; if (statusEl) statusEl.textContent = "Connected (sse)"; };
    source.onmessage = function(event) { handleLivePayload(event.data); };
    source.onerror = function() { state.liveError = "sse lost"; state.liveConnected = false; source.close(); if (statusEl) statusEl.textContent = "Disconnected"; };
  } catch(e) { state.liveError = "sse failed"; }
}

function handleLivePayload(payload) {
  var data = payload;
  if (typeof payload === "string") {
    try { data = JSON.parse(payload); } catch(e) {
      var edgeId = mapTraceToEdgeId(payload);
      if (edgeId) mergeIntoUnifiedTimeline({ name: "trace_line", detail: payload, edgeId: edgeId }, "daemon");
      return;
    }
  }
  if (data && typeof data === "object") {
    mergeIntoUnifiedTimeline(data, classifyEventSource(data));
    if (data.decision) state.lastDecision = data.decision;
    renderActivationTrace();
  }
}

function mapTraceToEdgeId(text) {
  var lowered = text.toLowerCase();
  var match = edges.find(function(edge) { return lowered.includes(edge.label.toLowerCase()) || lowered.includes(edge.name.toLowerCase()); });
  return match ? match.id : null;
}

/* ═══════════════════════════════════════════════════════════════
   PART 13: TAB SWITCHING
   ═══════════════════════════════════════════════════════════════ */
function setTab(tabId) {
  state.activeTab = tabId;
  document.querySelectorAll(".tab-btn").forEach(function(btn) { btn.classList.toggle("active", btn.dataset.tab === tabId); });
  document.querySelectorAll(".tab-content").forEach(function(el) { el.classList.toggle("active", el.id === "tab-" + tabId); });
  if (tabId === "live") {
    startSnapshotPolling();
    fetchSnapshot();
    connectTelemetrySSE();
    startTelemetryPolling();
    fetchTelemetry();
  } else {
    stopSnapshotPolling();
    stopTelemetryPolling();
    disconnectTelemetrySSE();
  }
}

/* ═══════════════════════════════════════════════════════════════
   PART 14: OVERLAYS
   ═══════════════════════════════════════════════════════════════ */
function toggleContractsOverlay() {
  var overlay = document.getElementById("contracts-overlay");
  if (overlay.style.display === "none") {
    var panel = document.getElementById("contracts-panel");
    panel.innerHTML = '<h2>Interface Contracts</h2><div class="contracts">' + contracts.map(function(c) {
      return '<article class="contract"><h4>' + c.title + '</h4><p>' + c.summary + '</p><ul>' + c.bullets.map(function(b) { return '<li>' + b + '</li>'; }).join('') + '</ul></article>';
    }).join('') + '</div><div class="overlay-dismiss">Press <kbd>C</kbd> or <kbd>Esc</kbd> to close</div>';
    overlay.style.display = "flex";
  } else { overlay.style.display = "none"; }
}
function toggleShortcutsOverlay() {
  var overlay = document.getElementById("shortcuts-overlay");
  if (overlay.style.display === "none") {
    document.getElementById("shortcuts-panel").innerHTML = '<h2>Keyboard Shortcuts</h2>' +
      '<div class="overlay-shortcut"><span class="key-col"><kbd>L</kbd></span> Toggle Learn / Live tab</div>' +
      '<div class="overlay-shortcut"><span class="key-col"><kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd></span> Switch flow (Learn tab)</div>' +
      '<div class="overlay-shortcut"><span class="key-col"><kbd>\u2190</kbd> <kbd>\u2192</kbd></span> Step back / forward (Learn tab)</div>' +
      '<div class="overlay-shortcut"><span class="key-col"><kbd>Space</kbd></span> Play / pause (Learn tab)</div>' +
      '<div class="overlay-shortcut"><span class="key-col"><kbd>R</kbd></span> Reset flow (Learn tab)</div>' +
      '<div class="overlay-shortcut"><span class="key-col"><kbd>C</kbd></span> Contracts overlay</div>' +
      '<div class="overlay-shortcut"><span class="key-col"><kbd>?</kbd></span> This help</div>' +
      '<div class="overlay-dismiss">Press <kbd>?</kbd> or <kbd>Esc</kbd> to close</div>';
    overlay.style.display = "flex";
  } else { overlay.style.display = "none"; }
}

/* ═══════════════════════════════════════════════════════════════
   PART 15: KEYBOARD SHORTCUTS
   ═══════════════════════════════════════════════════════════════ */
function initKeyboardShortcuts() {
  document.addEventListener("keydown", function(event) {
    if (event.defaultPrevented || event.metaKey || event.ctrlKey || event.altKey) return;
    var tag = event.target.tagName;
    if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || event.target.isContentEditable) return;

    if (event.key === "Escape") {
      event.preventDefault();
      if (state.detailPopoverOpen) { closeDetailPopover(); return; }
      document.getElementById("contracts-overlay").style.display = "none";
      document.getElementById("shortcuts-overlay").style.display = "none";
      return;
    }
    if (event.key === "l" || event.key === "L") {
      event.preventDefault();
      setTab(state.activeTab === "learn" ? "live" : "learn");
      return;
    }
    if (event.key === "c" || event.key === "C") { event.preventDefault(); toggleContractsOverlay(); return; }
    if (event.key === "?") { event.preventDefault(); toggleShortcutsOverlay(); return; }

    // Flow keys only active in Learn tab
    if (state.activeTab !== "learn") return;
    if (event.key === "1" && flows[0]) { event.preventDefault(); setFlow(flows[0].id); return; }
    if (event.key === "2" && flows[1]) { event.preventDefault(); setFlow(flows[1].id); return; }
    if (event.key === "3" && flows[2]) { event.preventDefault(); setFlow(flows[2].id); return; }
    if (event.key === "ArrowLeft") { event.preventDefault(); stepBack(); return; }
    if (event.key === "ArrowRight") { event.preventDefault(); stepForward(); return; }
    if (event.key === " " || event.key === "Spacebar") { event.preventDefault(); togglePlay(); return; }
    if (event.key === "r" || event.key === "R") { event.preventDefault(); resetFlow(); return; }
  });
}

/* ═══════════════════════════════════════════════════════════════
   PART 16: RENDER + INIT
   ═══════════════════════════════════════════════════════════════ */
function render() {
  renderLearnControls();
  renderFlowPanel();
  renderGraph();
  renderMinimap();
}

function init() {
  createNodeElements();
  createEdgeElements();
  initLearnControls();
  initMinimap();
  initKeyboardShortcuts();

  // Tab bar clicks
  document.querySelectorAll(".tab-btn").forEach(function(btn) {
    btn.addEventListener("click", function() { setTab(btn.dataset.tab); });
  });

  // Detail popover close on backdrop click
  document.getElementById("detail-popover").addEventListener("click", function(e) { if (e.target === this) closeDetailPopover(); });
  document.getElementById("contracts-overlay").addEventListener("click", function(e) { if (e.target === this) this.style.display = "none"; });
  document.getElementById("shortcuts-overlay").addEventListener("click", function(e) { if (e.target === this) this.style.display = "none"; });

  // Live tab controls
  var liveUrlEl = document.getElementById("live-url");
  var liveToggleEl = document.getElementById("live-toggle");
  var snapshotUrlEl = document.getElementById("snapshot-url");
  var snapshotRefreshEl = document.getElementById("snapshot-refresh");
  var snapshotAutoEl = document.getElementById("snapshot-auto");
  var timelineFilterEl = document.getElementById("timeline-filter");
  var timelineSourceEl = document.getElementById("timeline-source-filter");
  var timelineClearEl = document.getElementById("timeline-clear");

  liveUrlEl.value = state.liveUrl;
  liveUrlEl.addEventListener("change", function() { state.liveUrl = liveUrlEl.value.trim(); });
  liveToggleEl.addEventListener("click", function() {
    if (state.liveConnected) { disconnectLive(); liveToggleEl.textContent = "Connect"; document.getElementById("live-status").textContent = "Disconnected"; }
    else { connectLive(); liveToggleEl.textContent = "Disconnect"; }
  });

  snapshotUrlEl.value = state.snapshotUrl;
  snapshotUrlEl.addEventListener("change", function() { state.snapshotUrl = snapshotUrlEl.value.trim(); fetchSnapshot(); });
  snapshotRefreshEl.addEventListener("click", fetchSnapshot);
  snapshotAutoEl.checked = state.snapshotAuto;
  snapshotAutoEl.addEventListener("change", function() {
    state.snapshotAuto = snapshotAutoEl.checked;
    if (state.snapshotAuto && state.activeTab === "live") startSnapshotPolling(); else stopSnapshotPolling();
  });

  timelineFilterEl.addEventListener("input", function() { state.timelineFilter = timelineFilterEl.value; renderUnifiedTimeline(); });
  timelineSourceEl.addEventListener("change", function() { state.timelineSourceFilter = timelineSourceEl.value; renderUnifiedTimeline(); });
  timelineClearEl.addEventListener("click", function() { state.unifiedEvents = []; state.unifiedEventIds = new Set(); state.lastDecision = null; renderUnifiedTimeline(); renderActivationTrace(); });

  var traceTestBtn = document.getElementById("trace-test-btn");
  if (traceTestBtn) traceTestBtn.addEventListener("click", function() {
    var now = new Date().toISOString();
    var ago = function(min) { return new Date(Date.now() - min * 60000).toISOString(); };
    state.lastDecision = {
      outcome: "primary",
      prefer_tmux: false,
      policy_order: ["live", "path_rank", "tmux", "updated_at"],
      selected_pid: 73501,
      primary: { action: "activate_terminal", target: "Ghostty" },
      candidates: [
        { pid: 73501, cwd: "/Users/petepetrash/Code/capacitor", tty: "/dev/ttys004", parent_app: "Ghostty", is_live: true, has_tmux: false, match_type: "exact", match_rank: 1, updated_at: ago(2), rank_key: ["live=1", "path_rank=1", "tmux=0", "updated_at=" + ago(2), "pid=73501"] },
        { pid: 8005, cwd: "/Users/petepetrash/Code/todomi", tty: "/dev/ttys012", parent_app: "tmux", is_live: true, has_tmux: true, match_type: "none", match_rank: 4, updated_at: ago(45), rank_key: ["live=1", "path_rank=4", "tmux=1", "updated_at=" + ago(45), "pid=8005"] },
        { pid: 4632, cwd: "/Users/petepetrash/Code/claude-code-setup", tty: "/dev/ttys034", parent_app: "tmux", is_live: false, has_tmux: true, match_type: "parent", match_rank: 3, updated_at: ago(180), rank_key: ["live=0", "path_rank=3", "tmux=1", "updated_at=" + ago(180), "pid=4632"] },
        { pid: 1672, cwd: "/Users/petepetrash/Code/aui/tool-ui", tty: "/dev/ttys053", parent_app: "unknown", is_live: false, has_tmux: false, match_type: "child", match_rank: 2, updated_at: ago(1440), rank_key: ["live=0", "path_rank=2", "tmux=0", "updated_at=" + ago(1440), "pid=1672"] }
      ]
    };
    renderActivationTrace();
  });

  // Public API
  window.capacitorExplorer = {
    pushLiveTrace: function(payload) { mergeIntoUnifiedTimeline(payload, classifyEventSource(payload)); },
    setTab: setTab,
    setFlow: setFlow,
    connectLive: connectLive,
    disconnectLive: disconnectLive,
    setLiveUrl: function(url) { state.liveUrl = url; liveUrlEl.value = url; },
    setTelemetryUrl: function(url) { state.telemetryUrl = url; }
  };

  // Initial render
  setFlow(flows[0].id);
}

init();
</script>
</body>
</html>

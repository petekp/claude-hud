// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(hud_coreFFI)
    import hud_coreFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_hud_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_hud_core_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

/**
 * The main engine for Claude HUD operations.
 *
 * Provides a unified API for all HUD functionality, suitable for any client type.
 * This is the primary FFI interface for Swift/Kotlin/Python clients.
 */
public protocol HudEngineProtocol: AnyObject {
    /**
     * Adds a project to the pinned projects list.
     *
     * Also reconciles any orphaned locks for this path to ensure correct state display.
     */
    func addProject(path: String) throws

    /**
     * Returns the path to the Capacitor data directory as a string.
     * This is where Capacitor stores its own data (~/.capacitor by default).
     */
    func capacitorDir() -> String

    /**
     * Captures a new idea for a project.
     *
     * Appends the idea to `~/.capacitor/projects/{encoded}/ideas.md`
     * with default metadata (effort: unknown, status: open, triage: pending).
     *
     * Returns the generated ULID for the idea.
     */
    func captureIdea(projectPath: String, ideaText: String) throws -> String

    /**
     * Checks the status of a specific dependency.
     *
     * Supported dependencies: "tmux", "claude"
     */
    func checkDependency(name: String) -> DependencyStatus

    /**
     * Checks the health of the hook binary by examining its heartbeat file.
     *
     * The hook binary touches `~/.capacitor/hud-hook-heartbeat` on every event.
     * If the file's mtime is older than 60 seconds while sessions are active,
     * the hooks have likely stopped firing (binary crash, SIGKILL, etc.).
     *
     * Returns a health report with:
     * - `Healthy`: Heartbeat is fresh (within threshold)
     * - `Unknown`: No heartbeat file (hooks never fired)
     * - `Stale`: Heartbeat is old (hooks stopped firing)
     * - `Unreadable`: Can't read heartbeat file
     */
    func checkHookHealth() -> HookHealthReport

    /**
     * Checks the overall setup status including dependencies and hooks.
     *
     * Returns a comprehensive status object indicating:
     * - Which dependencies are installed (tmux, claude)
     * - Whether hooks are installed and up-to-date
     * - Whether storage is ready
     * - Any blocking issues preventing operation
     */
    func checkSetupStatus() -> SetupStatus

    /**
     * Returns the path to the Claude directory as a string.
     * This is the Claude Code data directory (~/.claude by default).
     */
    func claudeDir() -> String

    /**
     * Creates a CLAUDE.md file for a project.
     *
     * Returns Ok(()) if successful, or an error if the file couldn't be created.
     * Does NOT overwrite existing CLAUDE.md files.
     */
    func createProjectClaudeMd(projectPath: String) throws

    /**
     * Detects all agent sessions for a project path.
     *
     * Returns sessions from all installed agents (Claude, Codex, Aider, etc.)
     * that have active sessions at the given path or its children.
     */
    func getAgentSessions(projectPath: String) -> [AgentSession]

    /**
     * Gets all agent sessions across all projects (cached).
     *
     * Uses mtime-based caching for efficient repeated calls.
     * Call `invalidate_agent_cache()` to force a refresh.
     */
    func getAllAgentSessions() -> [AgentSession]

    /**
     * Gets session states for multiple projects.
     * Uses session-ID keyed state and lock detection for reliable state.
     *
     * Takes a Vec instead of slice for FFI compatibility.
     */
    func getAllSessionStates(projects: [Project]) -> [String: ProjectSessionState]

    /**
     * Gets the HUD configuration (pinned projects, terminal app, etc.)
     */
    func getConfig() -> HudConfig

    /**
     * Returns a unified diagnostic report for hook status.
     *
     * This combines setup status (is everything installed?) with health status
     * (are hooks actually firing?) into a single report for the UI.
     *
     * The report provides:
     * - `is_healthy`: True if everything is working
     * - `primary_issue`: The most critical issue to display (prioritized)
     * - `can_auto_fix`: True if "Fix All" can resolve the issue
     * - Individual status flags for checklist display
     */
    func getHookDiagnostic() -> HookDiagnosticReport

    /**
     * Returns the current hook status without full setup check.
     *
     * Useful for quick hook status checks in the UI.
     */
    func getHookStatus() -> HookStatus

    /**
     * Returns the file path where ideas are stored for a project.
     *
     * This is useful for mtime-based change detection in the UI.
     * Path: `~/.capacitor/projects/{encoded-path}/ideas.md`
     */
    func getIdeasFilePath(projectPath: String) -> String

    /**
     * Detects the primary agent session for a project path.
     *
     * Returns the first session found based on user preference order.
     * Use this when you only need to display one agent's state.
     */
    func getPrimaryAgentSession(projectPath: String) -> AgentSession?

    /**
     * Gets project status from .claude/hud-status.json.
     */
    func getProjectStatus(projectPath: String) -> ProjectStatus?

    /**
     * Gets the session state for a single project.
     * Uses session-ID keyed state and lock detection for reliable state.
     */
    func getSessionState(projectPath: String) -> ProjectSessionState

    /**
     * Discovers suggested projects based on activity in ~/.claude/projects.
     */
    func getSuggestedProjects() throws -> [SuggestedProject]

    /**
     * Installs the hook binary from a source path to ~/.local/bin/hud-hook.
     *
     * This is the platform-agnostic installation logic. The client is responsible
     * for finding the source binary (e.g., from macOS app bundle, Linux package, etc.).
     *
     * Returns success if:
     * - Binary already installed and executable
     * - Binary successfully copied and permissions set
     *
     * Returns error if:
     * - Source path doesn't exist
     * - Cannot create ~/.local/bin
     * - Cannot copy or set permissions
     */
    func installHookBinaryFromPath(sourcePath: String) throws -> InstallResult

    /**
     * Installs the session tracking hooks.
     *
     * This will:
     * 1. Verify the hook binary exists at ~/.local/bin/hud-hook
     * 2. Register the hooks in ~/.claude/settings.json
     *
     * Returns an error if:
     * - Hook binary is missing or broken
     * - Hooks are disabled by policy (disableAllHooks or allowManagedHooksOnly)
     * - File system operations fail
     */
    func installHooks() throws -> InstallResult

    /**
     * Invalidates the agent session cache.
     *
     * Call this when you know the underlying state has changed
     * and want to force a fresh read on the next call.
     */
    func invalidateAgentCache()

    /**
     * Lists all artifacts (skills, commands, agents) from global and plugin sources.
     */
    func listArtifacts() -> [Artifact]

    /**
     * Returns the list of installed agent IDs.
     *
     * Useful for debugging and UI display of which agents are available.
     */
    func listInstalledAgents() -> [String]

    /**
     * Lists all installed plugins.
     */
    func listPlugins() throws -> [Plugin]

    /**
     * Lists all pinned projects, sorted by most recent activity.
     */
    func listProjects() throws -> [Project]

    /**
     * Loads all dashboard data in one call.
     */
    func loadDashboard() throws -> DashboardData

    /**
     * Loads all ideas for a project.
     *
     * Returns an empty vector if the ideas file doesn't exist.
     */
    func loadIdeas(projectPath: String) throws -> [Idea]

    /**
     * Loads the display order of ideas for a project.
     *
     * Returns an empty vector if no order file exists (graceful degradation).
     * The caller should merge this with loaded ideas: ordered first, unordered appended.
     */
    func loadIdeasOrder(projectPath: String) throws -> [String]

    /**
     * Removes a project from the pinned projects list.
     */
    func removeProject(path: String) throws

    /**
     * Performs startup cleanup of stale artifacts.
     *
     * Call this once when the app launches to clean up:
     * - Lock directories with dead PIDs
     * - Session records older than 24 hours
     *
     * Returns stats about what was cleaned up.
     */
    func runStartupCleanup() -> CleanupStats

    /**
     * Saves the display order of ideas for a project.
     *
     * The order is stored separately from idea content in `~/.capacitor/projects/{encoded}/ideas-order.json`.
     * This prevents churning the ideas markdown file on every drag-reorder.
     */
    func saveIdeasOrder(projectPath: String, ideaIds: [String]) throws

    /**
     * Updates the description of an idea.
     *
     * Used for sensemaking - the idea is initially saved with raw user input,
     * then this is called with an AI-generated expansion.
     */
    func updateIdeaDescription(projectPath: String, ideaId: String, newDescription: String) throws

    /**
     * Updates the effort estimate of an idea.
     *
     * Valid efforts: unknown, small, medium, large, xl
     */
    func updateIdeaEffort(projectPath: String, ideaId: String, newEffort: String) throws

    /**
     * Updates the status of an idea.
     *
     * Valid statuses: open, in-progress, done
     */
    func updateIdeaStatus(projectPath: String, ideaId: String, newStatus: String) throws

    /**
     * Updates the title of an idea.
     *
     * Used for async title generation - the idea is initially saved with a placeholder,
     * then this is called once the AI-generated title is ready.
     */
    func updateIdeaTitle(projectPath: String, ideaId: String, newTitle: String) throws

    /**
     * Updates the triage status of an idea.
     *
     * Valid triage statuses: pending, validated
     */
    func updateIdeaTriage(projectPath: String, ideaId: String, newTriage: String) throws

    /**
     * Validates a project path before adding it.
     *
     * Returns validation result indicating whether the path is valid,
     * if there's a better path to use, or if the project is missing CLAUDE.md.
     *
     * This enables smart UI flows like:
     * - Suggesting parent directory when user picks a subdirectory
     * - Warning about dangerous paths (/, ~, etc.)
     * - Offering to create CLAUDE.md when missing
     * - Detecting if the project is already tracked
     */
    func validateProject(path: String) -> ValidationResultFfi
}

/**
 * The main engine for Claude HUD operations.
 *
 * Provides a unified API for all HUD functionality, suitable for any client type.
 * This is the primary FFI interface for Swift/Kotlin/Python clients.
 */
open class HudEngine:
    HudEngineProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_hud_core_fn_clone_hudengine(self.pointer, $0) }
    }

    /**
     * Creates a new HudEngine instance with default storage configuration.
     *
     * Uses `~/.capacitor/` for Capacitor data and `~/.claude/` for Claude data.
     */
    public convenience init() throws {
        let pointer =
            try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
                uniffi_hud_core_fn_constructor_hudengine_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_hud_core_fn_free_hudengine(pointer, $0) }
    }

    /**
     * Adds a project to the pinned projects list.
     *
     * Also reconciles any orphaned locks for this path to ensure correct state display.
     */
    open func addProject(path: String) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_add_project(self.uniffiClonePointer(),
                                                        FfiConverterString.lower(path), $0)
    }
    }

    /**
     * Returns the path to the Capacitor data directory as a string.
     * This is where Capacitor stores its own data (~/.capacitor by default).
     */
    open func capacitorDir() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_capacitor_dir(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Captures a new idea for a project.
     *
     * Appends the idea to `~/.capacitor/projects/{encoded}/ideas.md`
     * with default metadata (effort: unknown, status: open, triage: pending).
     *
     * Returns the generated ULID for the idea.
     */
    open func captureIdea(projectPath: String, ideaText: String) throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_capture_idea(self.uniffiClonePointer(),
                                                             FfiConverterString.lower(projectPath),
                                                             FfiConverterString.lower(ideaText), $0)
        })
    }

    /**
     * Checks the status of a specific dependency.
     *
     * Supported dependencies: "tmux", "claude"
     */
    open func checkDependency(name: String) -> DependencyStatus {
        return try! FfiConverterTypeDependencyStatus.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_check_dependency(self.uniffiClonePointer(),
                                                                 FfiConverterString.lower(name), $0)
        })
    }

    /**
     * Checks the health of the hook binary by examining its heartbeat file.
     *
     * The hook binary touches `~/.capacitor/hud-hook-heartbeat` on every event.
     * If the file's mtime is older than 60 seconds while sessions are active,
     * the hooks have likely stopped firing (binary crash, SIGKILL, etc.).
     *
     * Returns a health report with:
     * - `Healthy`: Heartbeat is fresh (within threshold)
     * - `Unknown`: No heartbeat file (hooks never fired)
     * - `Stale`: Heartbeat is old (hooks stopped firing)
     * - `Unreadable`: Can't read heartbeat file
     */
    open func checkHookHealth() -> HookHealthReport {
        return try! FfiConverterTypeHookHealthReport.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_check_hook_health(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Checks the overall setup status including dependencies and hooks.
     *
     * Returns a comprehensive status object indicating:
     * - Which dependencies are installed (tmux, claude)
     * - Whether hooks are installed and up-to-date
     * - Whether storage is ready
     * - Any blocking issues preventing operation
     */
    open func checkSetupStatus() -> SetupStatus {
        return try! FfiConverterTypeSetupStatus.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_check_setup_status(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the path to the Claude directory as a string.
     * This is the Claude Code data directory (~/.claude by default).
     */
    open func claudeDir() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_claude_dir(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Creates a CLAUDE.md file for a project.
     *
     * Returns Ok(()) if successful, or an error if the file couldn't be created.
     * Does NOT overwrite existing CLAUDE.md files.
     */
    open func createProjectClaudeMd(projectPath: String) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_create_project_claude_md(self.uniffiClonePointer(),
                                                                     FfiConverterString.lower(projectPath), $0)
    }
    }

    /**
     * Detects all agent sessions for a project path.
     *
     * Returns sessions from all installed agents (Claude, Codex, Aider, etc.)
     * that have active sessions at the given path or its children.
     */
    open func getAgentSessions(projectPath: String) -> [AgentSession] {
        return try! FfiConverterSequenceTypeAgentSession.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_agent_sessions(self.uniffiClonePointer(),
                                                                   FfiConverterString.lower(projectPath), $0)
        })
    }

    /**
     * Gets all agent sessions across all projects (cached).
     *
     * Uses mtime-based caching for efficient repeated calls.
     * Call `invalidate_agent_cache()` to force a refresh.
     */
    open func getAllAgentSessions() -> [AgentSession] {
        return try! FfiConverterSequenceTypeAgentSession.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_all_agent_sessions(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Gets session states for multiple projects.
     * Uses session-ID keyed state and lock detection for reliable state.
     *
     * Takes a Vec instead of slice for FFI compatibility.
     */
    open func getAllSessionStates(projects: [Project]) -> [String: ProjectSessionState] {
        return try! FfiConverterDictionaryStringTypeProjectSessionState.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_all_session_states(self.uniffiClonePointer(),
                                                                       FfiConverterSequenceTypeProject.lower(projects), $0)
        })
    }

    /**
     * Gets the HUD configuration (pinned projects, terminal app, etc.)
     */
    open func getConfig() -> HudConfig {
        return try! FfiConverterTypeHudConfig.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_config(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns a unified diagnostic report for hook status.
     *
     * This combines setup status (is everything installed?) with health status
     * (are hooks actually firing?) into a single report for the UI.
     *
     * The report provides:
     * - `is_healthy`: True if everything is working
     * - `primary_issue`: The most critical issue to display (prioritized)
     * - `can_auto_fix`: True if "Fix All" can resolve the issue
     * - Individual status flags for checklist display
     */
    open func getHookDiagnostic() -> HookDiagnosticReport {
        return try! FfiConverterTypeHookDiagnosticReport.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_hook_diagnostic(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the current hook status without full setup check.
     *
     * Useful for quick hook status checks in the UI.
     */
    open func getHookStatus() -> HookStatus {
        return try! FfiConverterTypeHookStatus.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_hook_status(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the file path where ideas are stored for a project.
     *
     * This is useful for mtime-based change detection in the UI.
     * Path: `~/.capacitor/projects/{encoded-path}/ideas.md`
     */
    open func getIdeasFilePath(projectPath: String) -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_ideas_file_path(self.uniffiClonePointer(),
                                                                    FfiConverterString.lower(projectPath), $0)
        })
    }

    /**
     * Detects the primary agent session for a project path.
     *
     * Returns the first session found based on user preference order.
     * Use this when you only need to display one agent's state.
     */
    open func getPrimaryAgentSession(projectPath: String) -> AgentSession? {
        return try! FfiConverterOptionTypeAgentSession.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_primary_agent_session(self.uniffiClonePointer(),
                                                                          FfiConverterString.lower(projectPath), $0)
        })
    }

    /**
     * Gets project status from .claude/hud-status.json.
     */
    open func getProjectStatus(projectPath: String) -> ProjectStatus? {
        return try! FfiConverterOptionTypeProjectStatus.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_project_status(self.uniffiClonePointer(),
                                                                   FfiConverterString.lower(projectPath), $0)
        })
    }

    /**
     * Gets the session state for a single project.
     * Uses session-ID keyed state and lock detection for reliable state.
     */
    open func getSessionState(projectPath: String) -> ProjectSessionState {
        return try! FfiConverterTypeProjectSessionState.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_get_session_state(self.uniffiClonePointer(),
                                                                  FfiConverterString.lower(projectPath), $0)
        })
    }

    /**
     * Discovers suggested projects based on activity in ~/.claude/projects.
     */
    open func getSuggestedProjects() throws -> [SuggestedProject] {
        return try FfiConverterSequenceTypeSuggestedProject.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_get_suggested_projects(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Installs the hook binary from a source path to ~/.local/bin/hud-hook.
     *
     * This is the platform-agnostic installation logic. The client is responsible
     * for finding the source binary (e.g., from macOS app bundle, Linux package, etc.).
     *
     * Returns success if:
     * - Binary already installed and executable
     * - Binary successfully copied and permissions set
     *
     * Returns error if:
     * - Source path doesn't exist
     * - Cannot create ~/.local/bin
     * - Cannot copy or set permissions
     */
    open func installHookBinaryFromPath(sourcePath: String) throws -> InstallResult {
        return try FfiConverterTypeInstallResult.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_install_hook_binary_from_path(self.uniffiClonePointer(),
                                                                              FfiConverterString.lower(sourcePath), $0)
        })
    }

    /**
     * Installs the session tracking hooks.
     *
     * This will:
     * 1. Verify the hook binary exists at ~/.local/bin/hud-hook
     * 2. Register the hooks in ~/.claude/settings.json
     *
     * Returns an error if:
     * - Hook binary is missing or broken
     * - Hooks are disabled by policy (disableAllHooks or allowManagedHooksOnly)
     * - File system operations fail
     */
    open func installHooks() throws -> InstallResult {
        return try FfiConverterTypeInstallResult.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_install_hooks(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Invalidates the agent session cache.
     *
     * Call this when you know the underlying state has changed
     * and want to force a fresh read on the next call.
     */
    open func invalidateAgentCache() { try! rustCall {
        uniffi_hud_core_fn_method_hudengine_invalidate_agent_cache(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Lists all artifacts (skills, commands, agents) from global and plugin sources.
     */
    open func listArtifacts() -> [Artifact] {
        return try! FfiConverterSequenceTypeArtifact.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_list_artifacts(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the list of installed agent IDs.
     *
     * Useful for debugging and UI display of which agents are available.
     */
    open func listInstalledAgents() -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_list_installed_agents(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Lists all installed plugins.
     */
    open func listPlugins() throws -> [Plugin] {
        return try FfiConverterSequenceTypePlugin.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_list_plugins(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Lists all pinned projects, sorted by most recent activity.
     */
    open func listProjects() throws -> [Project] {
        return try FfiConverterSequenceTypeProject.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_list_projects(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Loads all dashboard data in one call.
     */
    open func loadDashboard() throws -> DashboardData {
        return try FfiConverterTypeDashboardData.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_load_dashboard(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Loads all ideas for a project.
     *
     * Returns an empty vector if the ideas file doesn't exist.
     */
    open func loadIdeas(projectPath: String) throws -> [Idea] {
        return try FfiConverterSequenceTypeIdea.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_load_ideas(self.uniffiClonePointer(),
                                                           FfiConverterString.lower(projectPath), $0)
        })
    }

    /**
     * Loads the display order of ideas for a project.
     *
     * Returns an empty vector if no order file exists (graceful degradation).
     * The caller should merge this with loaded ideas: ordered first, unordered appended.
     */
    open func loadIdeasOrder(projectPath: String) throws -> [String] {
        return try FfiConverterSequenceString.lift(rustCallWithError(FfiConverterTypeHudFfiError.lift) {
            uniffi_hud_core_fn_method_hudengine_load_ideas_order(self.uniffiClonePointer(),
                                                                 FfiConverterString.lower(projectPath), $0)
        })
    }

    /**
     * Removes a project from the pinned projects list.
     */
    open func removeProject(path: String) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_remove_project(self.uniffiClonePointer(),
                                                           FfiConverterString.lower(path), $0)
    }
    }

    /**
     * Performs startup cleanup of stale artifacts.
     *
     * Call this once when the app launches to clean up:
     * - Lock directories with dead PIDs
     * - Session records older than 24 hours
     *
     * Returns stats about what was cleaned up.
     */
    open func runStartupCleanup() -> CleanupStats {
        return try! FfiConverterTypeCleanupStats.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_run_startup_cleanup(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Saves the display order of ideas for a project.
     *
     * The order is stored separately from idea content in `~/.capacitor/projects/{encoded}/ideas-order.json`.
     * This prevents churning the ideas markdown file on every drag-reorder.
     */
    open func saveIdeasOrder(projectPath: String, ideaIds: [String]) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_save_ideas_order(self.uniffiClonePointer(),
                                                             FfiConverterString.lower(projectPath),
                                                             FfiConverterSequenceString.lower(ideaIds), $0)
    }
    }

    /**
     * Updates the description of an idea.
     *
     * Used for sensemaking - the idea is initially saved with raw user input,
     * then this is called with an AI-generated expansion.
     */
    open func updateIdeaDescription(projectPath: String, ideaId: String, newDescription: String) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_update_idea_description(self.uniffiClonePointer(),
                                                                    FfiConverterString.lower(projectPath),
                                                                    FfiConverterString.lower(ideaId),
                                                                    FfiConverterString.lower(newDescription), $0)
    }
    }

    /**
     * Updates the effort estimate of an idea.
     *
     * Valid efforts: unknown, small, medium, large, xl
     */
    open func updateIdeaEffort(projectPath: String, ideaId: String, newEffort: String) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_update_idea_effort(self.uniffiClonePointer(),
                                                               FfiConverterString.lower(projectPath),
                                                               FfiConverterString.lower(ideaId),
                                                               FfiConverterString.lower(newEffort), $0)
    }
    }

    /**
     * Updates the status of an idea.
     *
     * Valid statuses: open, in-progress, done
     */
    open func updateIdeaStatus(projectPath: String, ideaId: String, newStatus: String) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_update_idea_status(self.uniffiClonePointer(),
                                                               FfiConverterString.lower(projectPath),
                                                               FfiConverterString.lower(ideaId),
                                                               FfiConverterString.lower(newStatus), $0)
    }
    }

    /**
     * Updates the title of an idea.
     *
     * Used for async title generation - the idea is initially saved with a placeholder,
     * then this is called once the AI-generated title is ready.
     */
    open func updateIdeaTitle(projectPath: String, ideaId: String, newTitle: String) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_update_idea_title(self.uniffiClonePointer(),
                                                              FfiConverterString.lower(projectPath),
                                                              FfiConverterString.lower(ideaId),
                                                              FfiConverterString.lower(newTitle), $0)
    }
    }

    /**
     * Updates the triage status of an idea.
     *
     * Valid triage statuses: pending, validated
     */
    open func updateIdeaTriage(projectPath: String, ideaId: String, newTriage: String) throws { try rustCallWithError(FfiConverterTypeHudFfiError.lift) {
        uniffi_hud_core_fn_method_hudengine_update_idea_triage(self.uniffiClonePointer(),
                                                               FfiConverterString.lower(projectPath),
                                                               FfiConverterString.lower(ideaId),
                                                               FfiConverterString.lower(newTriage), $0)
    }
    }

    /**
     * Validates a project path before adding it.
     *
     * Returns validation result indicating whether the path is valid,
     * if there's a better path to use, or if the project is missing CLAUDE.md.
     *
     * This enables smart UI flows like:
     * - Suggesting parent directory when user picks a subdirectory
     * - Warning about dangerous paths (/, ~, etc.)
     * - Offering to create CLAUDE.md when missing
     * - Detecting if the project is already tracked
     */
    open func validateProject(path: String) -> ValidationResultFfi {
        return try! FfiConverterTypeValidationResultFfi.lift(try! rustCall {
            uniffi_hud_core_fn_method_hudengine_validate_project(self.uniffiClonePointer(),
                                                                 FfiConverterString.lower(path), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHudEngine: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HudEngine

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HudEngine {
        return HudEngine(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HudEngine) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HudEngine {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HudEngine, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHudEngine_lift(_ pointer: UnsafeMutableRawPointer) throws -> HudEngine {
    return try FfiConverterTypeHudEngine.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHudEngine_lower(_ value: HudEngine) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHudEngine.lower(value)
}

/**
 * A detected agent session
 *
 * NOTE: The composite key is (agent_type, session_id). Session IDs are only
 * unique within an agent type, not globally.
 */
public struct AgentSession {
    public var agentType: AgentType
    public var agentName: String
    public var state: AgentState
    public var sessionId: String?
    public var cwd: String
    public var detail: String?
    public var workingOn: String?
    public var updatedAt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(agentType: AgentType, agentName: String, state: AgentState, sessionId: String?, cwd: String, detail: String?, workingOn: String?, updatedAt: String?) {
        self.agentType = agentType
        self.agentName = agentName
        self.state = state
        self.sessionId = sessionId
        self.cwd = cwd
        self.detail = detail
        self.workingOn = workingOn
        self.updatedAt = updatedAt
    }
}

extension AgentSession: Equatable, Hashable {
    public static func == (lhs: AgentSession, rhs: AgentSession) -> Bool {
        if lhs.agentType != rhs.agentType {
            return false
        }
        if lhs.agentName != rhs.agentName {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.cwd != rhs.cwd {
            return false
        }
        if lhs.detail != rhs.detail {
            return false
        }
        if lhs.workingOn != rhs.workingOn {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(agentType)
        hasher.combine(agentName)
        hasher.combine(state)
        hasher.combine(sessionId)
        hasher.combine(cwd)
        hasher.combine(detail)
        hasher.combine(workingOn)
        hasher.combine(updatedAt)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAgentSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AgentSession {
        return
            try AgentSession(
                agentType: FfiConverterTypeAgentType.read(from: &buf),
                agentName: FfiConverterString.read(from: &buf),
                state: FfiConverterTypeAgentState.read(from: &buf),
                sessionId: FfiConverterOptionString.read(from: &buf),
                cwd: FfiConverterString.read(from: &buf),
                detail: FfiConverterOptionString.read(from: &buf),
                workingOn: FfiConverterOptionString.read(from: &buf),
                updatedAt: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: AgentSession, into buf: inout [UInt8]) {
        FfiConverterTypeAgentType.write(value.agentType, into: &buf)
        FfiConverterString.write(value.agentName, into: &buf)
        FfiConverterTypeAgentState.write(value.state, into: &buf)
        FfiConverterOptionString.write(value.sessionId, into: &buf)
        FfiConverterString.write(value.cwd, into: &buf)
        FfiConverterOptionString.write(value.detail, into: &buf)
        FfiConverterOptionString.write(value.workingOn, into: &buf)
        FfiConverterOptionString.write(value.updatedAt, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAgentSession_lift(_ buf: RustBuffer) throws -> AgentSession {
    return try FfiConverterTypeAgentSession.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAgentSession_lower(_ value: AgentSession) -> RustBuffer {
    return FfiConverterTypeAgentSession.lower(value)
}

/**
 * A skill, command, or agent definition.
 */
public struct Artifact {
    public var artifactType: String
    public var name: String
    public var description: String
    public var source: String
    public var path: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(artifactType: String, name: String, description: String, source: String, path: String) {
        self.artifactType = artifactType
        self.name = name
        self.description = description
        self.source = source
        self.path = path
    }
}

extension Artifact: Equatable, Hashable {
    public static func == (lhs: Artifact, rhs: Artifact) -> Bool {
        if lhs.artifactType != rhs.artifactType {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(artifactType)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(source)
        hasher.combine(path)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeArtifact: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Artifact {
        return
            try Artifact(
                artifactType: FfiConverterString.read(from: &buf),
                name: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                source: FfiConverterString.read(from: &buf),
                path: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: Artifact, into buf: inout [UInt8]) {
        FfiConverterString.write(value.artifactType, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterString.write(value.path, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeArtifact_lift(_ buf: RustBuffer) throws -> Artifact {
    return try FfiConverterTypeArtifact.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeArtifact_lower(_ value: Artifact) -> RustBuffer {
    return FfiConverterTypeArtifact.lower(value)
}

/**
 * Cached file metadata for cache invalidation.
 */
public struct CachedFileInfo {
    public var size: UInt64
    public var mtime: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(size: UInt64, mtime: UInt64) {
        self.size = size
        self.mtime = mtime
    }
}

extension CachedFileInfo: Equatable, Hashable {
    public static func == (lhs: CachedFileInfo, rhs: CachedFileInfo) -> Bool {
        if lhs.size != rhs.size {
            return false
        }
        if lhs.mtime != rhs.mtime {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(size)
        hasher.combine(mtime)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCachedFileInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CachedFileInfo {
        return
            try CachedFileInfo(
                size: FfiConverterUInt64.read(from: &buf),
                mtime: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: CachedFileInfo, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterUInt64.write(value.mtime, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCachedFileInfo_lift(_ buf: RustBuffer) throws -> CachedFileInfo {
    return try FfiConverterTypeCachedFileInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCachedFileInfo_lower(_ value: CachedFileInfo) -> RustBuffer {
    return FfiConverterTypeCachedFileInfo.lower(value)
}

/**
 * Cached statistics for a single project.
 */
public struct CachedProjectStats {
    public var files: [String: CachedFileInfo]
    public var stats: ProjectStats

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(files: [String: CachedFileInfo], stats: ProjectStats) {
        self.files = files
        self.stats = stats
    }
}

extension CachedProjectStats: Equatable, Hashable {
    public static func == (lhs: CachedProjectStats, rhs: CachedProjectStats) -> Bool {
        if lhs.files != rhs.files {
            return false
        }
        if lhs.stats != rhs.stats {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(files)
        hasher.combine(stats)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCachedProjectStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CachedProjectStats {
        return
            try CachedProjectStats(
                files: FfiConverterDictionaryStringTypeCachedFileInfo.read(from: &buf),
                stats: FfiConverterTypeProjectStats.read(from: &buf)
            )
    }

    public static func write(_ value: CachedProjectStats, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeCachedFileInfo.write(value.files, into: &buf)
        FfiConverterTypeProjectStats.write(value.stats, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCachedProjectStats_lift(_ buf: RustBuffer) throws -> CachedProjectStats {
    return try FfiConverterTypeCachedProjectStats.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCachedProjectStats_lower(_ value: CachedProjectStats) -> RustBuffer {
    return FfiConverterTypeCachedProjectStats.lower(value)
}

/**
 * Results from a cleanup operation.
 */
public struct CleanupStats {
    /**
     * Number of stale lock directories removed.
     */
    public var locksRemoved: UInt32
    /**
     * Number of legacy MD5-hash locks removed.
     */
    public var legacyLocksRemoved: UInt32
    /**
     * Number of orphaned lock-holder processes killed.
     */
    public var orphanedProcessesKilled: UInt32
    /**
     * Number of orphaned session records removed (no active lock).
     */
    public var orphanedSessionsRemoved: UInt32
    /**
     * Number of old session records removed (> 24 hours).
     */
    public var sessionsRemoved: UInt32
    /**
     * Number of old tombstone files removed.
     */
    public var tombstonesRemoved: UInt32
    /**
     * Errors encountered during cleanup.
     */
    public var errors: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Number of stale lock directories removed.
         */ locksRemoved: UInt32,
        /**
            * Number of legacy MD5-hash locks removed.
            */ legacyLocksRemoved: UInt32,
        /**
            * Number of orphaned lock-holder processes killed.
            */ orphanedProcessesKilled: UInt32,
        /**
            * Number of orphaned session records removed (no active lock).
            */ orphanedSessionsRemoved: UInt32,
        /**
            * Number of old session records removed (> 24 hours).
            */ sessionsRemoved: UInt32,
        /**
            * Number of old tombstone files removed.
            */ tombstonesRemoved: UInt32,
        /**
            * Errors encountered during cleanup.
            */ errors: [String]
    ) {
        self.locksRemoved = locksRemoved
        self.legacyLocksRemoved = legacyLocksRemoved
        self.orphanedProcessesKilled = orphanedProcessesKilled
        self.orphanedSessionsRemoved = orphanedSessionsRemoved
        self.sessionsRemoved = sessionsRemoved
        self.tombstonesRemoved = tombstonesRemoved
        self.errors = errors
    }
}

extension CleanupStats: Equatable, Hashable {
    public static func == (lhs: CleanupStats, rhs: CleanupStats) -> Bool {
        if lhs.locksRemoved != rhs.locksRemoved {
            return false
        }
        if lhs.legacyLocksRemoved != rhs.legacyLocksRemoved {
            return false
        }
        if lhs.orphanedProcessesKilled != rhs.orphanedProcessesKilled {
            return false
        }
        if lhs.orphanedSessionsRemoved != rhs.orphanedSessionsRemoved {
            return false
        }
        if lhs.sessionsRemoved != rhs.sessionsRemoved {
            return false
        }
        if lhs.tombstonesRemoved != rhs.tombstonesRemoved {
            return false
        }
        if lhs.errors != rhs.errors {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(locksRemoved)
        hasher.combine(legacyLocksRemoved)
        hasher.combine(orphanedProcessesKilled)
        hasher.combine(orphanedSessionsRemoved)
        hasher.combine(sessionsRemoved)
        hasher.combine(tombstonesRemoved)
        hasher.combine(errors)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCleanupStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CleanupStats {
        return
            try CleanupStats(
                locksRemoved: FfiConverterUInt32.read(from: &buf),
                legacyLocksRemoved: FfiConverterUInt32.read(from: &buf),
                orphanedProcessesKilled: FfiConverterUInt32.read(from: &buf),
                orphanedSessionsRemoved: FfiConverterUInt32.read(from: &buf),
                sessionsRemoved: FfiConverterUInt32.read(from: &buf),
                tombstonesRemoved: FfiConverterUInt32.read(from: &buf),
                errors: FfiConverterSequenceString.read(from: &buf)
            )
    }

    public static func write(_ value: CleanupStats, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.locksRemoved, into: &buf)
        FfiConverterUInt32.write(value.legacyLocksRemoved, into: &buf)
        FfiConverterUInt32.write(value.orphanedProcessesKilled, into: &buf)
        FfiConverterUInt32.write(value.orphanedSessionsRemoved, into: &buf)
        FfiConverterUInt32.write(value.sessionsRemoved, into: &buf)
        FfiConverterUInt32.write(value.tombstonesRemoved, into: &buf)
        FfiConverterSequenceString.write(value.errors, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCleanupStats_lift(_ buf: RustBuffer) throws -> CleanupStats {
    return try FfiConverterTypeCleanupStats.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCleanupStats_lower(_ value: CleanupStats) -> RustBuffer {
    return FfiConverterTypeCleanupStats.lower(value)
}

/**
 * Context window usage information.
 */
public struct ContextInfo {
    public var percentUsed: UInt32
    public var tokensUsed: UInt64
    public var contextSize: UInt64
    public var updatedAt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(percentUsed: UInt32, tokensUsed: UInt64, contextSize: UInt64, updatedAt: String?) {
        self.percentUsed = percentUsed
        self.tokensUsed = tokensUsed
        self.contextSize = contextSize
        self.updatedAt = updatedAt
    }
}

extension ContextInfo: Equatable, Hashable {
    public static func == (lhs: ContextInfo, rhs: ContextInfo) -> Bool {
        if lhs.percentUsed != rhs.percentUsed {
            return false
        }
        if lhs.tokensUsed != rhs.tokensUsed {
            return false
        }
        if lhs.contextSize != rhs.contextSize {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(percentUsed)
        hasher.combine(tokensUsed)
        hasher.combine(contextSize)
        hasher.combine(updatedAt)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeContextInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContextInfo {
        return
            try ContextInfo(
                percentUsed: FfiConverterUInt32.read(from: &buf),
                tokensUsed: FfiConverterUInt64.read(from: &buf),
                contextSize: FfiConverterUInt64.read(from: &buf),
                updatedAt: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: ContextInfo, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.percentUsed, into: &buf)
        FfiConverterUInt64.write(value.tokensUsed, into: &buf)
        FfiConverterUInt64.write(value.contextSize, into: &buf)
        FfiConverterOptionString.write(value.updatedAt, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeContextInfo_lift(_ buf: RustBuffer) throws -> ContextInfo {
    return try FfiConverterTypeContextInfo.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeContextInfo_lower(_ value: ContextInfo) -> RustBuffer {
    return FfiConverterTypeContextInfo.lower(value)
}

/**
 * Result of starting a project creation.
 */
public struct CreateProjectResult {
    public var success: Bool
    public var projectPath: String
    public var sessionId: String?
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(success: Bool, projectPath: String, sessionId: String?, error: String?) {
        self.success = success
        self.projectPath = projectPath
        self.sessionId = sessionId
        self.error = error
    }
}

extension CreateProjectResult: Equatable, Hashable {
    public static func == (lhs: CreateProjectResult, rhs: CreateProjectResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.projectPath != rhs.projectPath {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(projectPath)
        hasher.combine(sessionId)
        hasher.combine(error)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateProjectResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateProjectResult {
        return
            try CreateProjectResult(
                success: FfiConverterBool.read(from: &buf),
                projectPath: FfiConverterString.read(from: &buf),
                sessionId: FfiConverterOptionString.read(from: &buf),
                error: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: CreateProjectResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterString.write(value.projectPath, into: &buf)
        FfiConverterOptionString.write(value.sessionId, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateProjectResult_lift(_ buf: RustBuffer) throws -> CreateProjectResult {
    return try FfiConverterTypeCreateProjectResult.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateProjectResult_lower(_ value: CreateProjectResult) -> RustBuffer {
    return FfiConverterTypeCreateProjectResult.lower(value)
}

/**
 * Progress information for a project creation.
 */
public struct CreationProgress {
    public var phase: String
    public var message: String
    public var percentComplete: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(phase: String, message: String, percentComplete: UInt8?) {
        self.phase = phase
        self.message = message
        self.percentComplete = percentComplete
    }
}

extension CreationProgress: Equatable, Hashable {
    public static func == (lhs: CreationProgress, rhs: CreationProgress) -> Bool {
        if lhs.phase != rhs.phase {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.percentComplete != rhs.percentComplete {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(phase)
        hasher.combine(message)
        hasher.combine(percentComplete)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreationProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreationProgress {
        return
            try CreationProgress(
                phase: FfiConverterString.read(from: &buf),
                message: FfiConverterString.read(from: &buf),
                percentComplete: FfiConverterOptionUInt8.read(from: &buf)
            )
    }

    public static func write(_ value: CreationProgress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.phase, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterOptionUInt8.write(value.percentComplete, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCreationProgress_lift(_ buf: RustBuffer) throws -> CreationProgress {
    return try FfiConverterTypeCreationProgress.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCreationProgress_lower(_ value: CreationProgress) -> RustBuffer {
    return FfiConverterTypeCreationProgress.lower(value)
}

/**
 * Aggregate data for the dashboard view.
 */
public struct DashboardData {
    public var global: GlobalConfig
    public var plugins: [Plugin]
    public var projects: [Project]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(global: GlobalConfig, plugins: [Plugin], projects: [Project]) {
        self.global = global
        self.plugins = plugins
        self.projects = projects
    }
}

extension DashboardData: Equatable, Hashable {
    public static func == (lhs: DashboardData, rhs: DashboardData) -> Bool {
        if lhs.global != rhs.global {
            return false
        }
        if lhs.plugins != rhs.plugins {
            return false
        }
        if lhs.projects != rhs.projects {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(global)
        hasher.combine(plugins)
        hasher.combine(projects)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeDashboardData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DashboardData {
        return
            try DashboardData(
                global: FfiConverterTypeGlobalConfig.read(from: &buf),
                plugins: FfiConverterSequenceTypePlugin.read(from: &buf),
                projects: FfiConverterSequenceTypeProject.read(from: &buf)
            )
    }

    public static func write(_ value: DashboardData, into buf: inout [UInt8]) {
        FfiConverterTypeGlobalConfig.write(value.global, into: &buf)
        FfiConverterSequenceTypePlugin.write(value.plugins, into: &buf)
        FfiConverterSequenceTypeProject.write(value.projects, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeDashboardData_lift(_ buf: RustBuffer) throws -> DashboardData {
    return try FfiConverterTypeDashboardData.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeDashboardData_lower(_ value: DashboardData) -> RustBuffer {
    return FfiConverterTypeDashboardData.lower(value)
}

public struct DependencyStatus {
    public var name: String
    public var required: Bool
    public var found: Bool
    public var path: String?
    public var installHint: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, required: Bool, found: Bool, path: String?, installHint: String?) {
        self.name = name
        self.required = required
        self.found = found
        self.path = path
        self.installHint = installHint
    }
}

extension DependencyStatus: Equatable, Hashable {
    public static func == (lhs: DependencyStatus, rhs: DependencyStatus) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.required != rhs.required {
            return false
        }
        if lhs.found != rhs.found {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.installHint != rhs.installHint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(required)
        hasher.combine(found)
        hasher.combine(path)
        hasher.combine(installHint)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeDependencyStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DependencyStatus {
        return
            try DependencyStatus(
                name: FfiConverterString.read(from: &buf),
                required: FfiConverterBool.read(from: &buf),
                found: FfiConverterBool.read(from: &buf),
                path: FfiConverterOptionString.read(from: &buf),
                installHint: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: DependencyStatus, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterBool.write(value.required, into: &buf)
        FfiConverterBool.write(value.found, into: &buf)
        FfiConverterOptionString.write(value.path, into: &buf)
        FfiConverterOptionString.write(value.installHint, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeDependencyStatus_lift(_ buf: RustBuffer) throws -> DependencyStatus {
    return try FfiConverterTypeDependencyStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeDependencyStatus_lower(_ value: DependencyStatus) -> RustBuffer {
    return FfiConverterTypeDependencyStatus.lower(value)
}

/**
 * Global Claude Code configuration and artifact counts.
 */
public struct GlobalConfig {
    public var settingsPath: String
    public var settingsExists: Bool
    public var instructionsPath: String?
    public var skillsDir: String?
    public var commandsDir: String?
    public var agentsDir: String?
    public var skillCount: UInt32
    public var commandCount: UInt32
    public var agentCount: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(settingsPath: String, settingsExists: Bool, instructionsPath: String?, skillsDir: String?, commandsDir: String?, agentsDir: String?, skillCount: UInt32, commandCount: UInt32, agentCount: UInt32) {
        self.settingsPath = settingsPath
        self.settingsExists = settingsExists
        self.instructionsPath = instructionsPath
        self.skillsDir = skillsDir
        self.commandsDir = commandsDir
        self.agentsDir = agentsDir
        self.skillCount = skillCount
        self.commandCount = commandCount
        self.agentCount = agentCount
    }
}

extension GlobalConfig: Equatable, Hashable {
    public static func == (lhs: GlobalConfig, rhs: GlobalConfig) -> Bool {
        if lhs.settingsPath != rhs.settingsPath {
            return false
        }
        if lhs.settingsExists != rhs.settingsExists {
            return false
        }
        if lhs.instructionsPath != rhs.instructionsPath {
            return false
        }
        if lhs.skillsDir != rhs.skillsDir {
            return false
        }
        if lhs.commandsDir != rhs.commandsDir {
            return false
        }
        if lhs.agentsDir != rhs.agentsDir {
            return false
        }
        if lhs.skillCount != rhs.skillCount {
            return false
        }
        if lhs.commandCount != rhs.commandCount {
            return false
        }
        if lhs.agentCount != rhs.agentCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(settingsPath)
        hasher.combine(settingsExists)
        hasher.combine(instructionsPath)
        hasher.combine(skillsDir)
        hasher.combine(commandsDir)
        hasher.combine(agentsDir)
        hasher.combine(skillCount)
        hasher.combine(commandCount)
        hasher.combine(agentCount)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeGlobalConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalConfig {
        return
            try GlobalConfig(
                settingsPath: FfiConverterString.read(from: &buf),
                settingsExists: FfiConverterBool.read(from: &buf),
                instructionsPath: FfiConverterOptionString.read(from: &buf),
                skillsDir: FfiConverterOptionString.read(from: &buf),
                commandsDir: FfiConverterOptionString.read(from: &buf),
                agentsDir: FfiConverterOptionString.read(from: &buf),
                skillCount: FfiConverterUInt32.read(from: &buf),
                commandCount: FfiConverterUInt32.read(from: &buf),
                agentCount: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: GlobalConfig, into buf: inout [UInt8]) {
        FfiConverterString.write(value.settingsPath, into: &buf)
        FfiConverterBool.write(value.settingsExists, into: &buf)
        FfiConverterOptionString.write(value.instructionsPath, into: &buf)
        FfiConverterOptionString.write(value.skillsDir, into: &buf)
        FfiConverterOptionString.write(value.commandsDir, into: &buf)
        FfiConverterOptionString.write(value.agentsDir, into: &buf)
        FfiConverterUInt32.write(value.skillCount, into: &buf)
        FfiConverterUInt32.write(value.commandCount, into: &buf)
        FfiConverterUInt32.write(value.agentCount, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfig_lift(_ buf: RustBuffer) throws -> GlobalConfig {
    return try FfiConverterTypeGlobalConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeGlobalConfig_lower(_ value: GlobalConfig) -> RustBuffer {
    return FfiConverterTypeGlobalConfig.lower(value)
}

/**
 * Unified diagnostic report combining installation status and runtime health.
 *
 * This provides a single source of truth for the UI to determine what to show
 * and whether auto-fix is available.
 */
public struct HookDiagnosticReport {
    /**
     * True if everything is working correctly
     */
    public var isHealthy: Bool
    /**
     * The most critical issue to display (if any)
     */
    public var primaryIssue: HookIssue?
    /**
     * True if "Fix All" can resolve the issue
     */
    public var canAutoFix: Bool
    /**
     * Whether this appears to be a first-time setup (no heartbeat ever seen)
     */
    public var isFirstRun: Bool
    /**
     * Detailed status for checklist display
     */
    public var binaryOk: Bool
    public var configOk: Bool
    public var firingOk: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * True if everything is working correctly
         */ isHealthy: Bool,
        /**
            * The most critical issue to display (if any)
            */ primaryIssue: HookIssue?,
        /**
            * True if "Fix All" can resolve the issue
            */ canAutoFix: Bool,
        /**
            * Whether this appears to be a first-time setup (no heartbeat ever seen)
            */ isFirstRun: Bool,
        /**
            * Detailed status for checklist display
            */ binaryOk: Bool, configOk: Bool, firingOk: Bool
    ) {
        self.isHealthy = isHealthy
        self.primaryIssue = primaryIssue
        self.canAutoFix = canAutoFix
        self.isFirstRun = isFirstRun
        self.binaryOk = binaryOk
        self.configOk = configOk
        self.firingOk = firingOk
    }
}

extension HookDiagnosticReport: Equatable, Hashable {
    public static func == (lhs: HookDiagnosticReport, rhs: HookDiagnosticReport) -> Bool {
        if lhs.isHealthy != rhs.isHealthy {
            return false
        }
        if lhs.primaryIssue != rhs.primaryIssue {
            return false
        }
        if lhs.canAutoFix != rhs.canAutoFix {
            return false
        }
        if lhs.isFirstRun != rhs.isFirstRun {
            return false
        }
        if lhs.binaryOk != rhs.binaryOk {
            return false
        }
        if lhs.configOk != rhs.configOk {
            return false
        }
        if lhs.firingOk != rhs.firingOk {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isHealthy)
        hasher.combine(primaryIssue)
        hasher.combine(canAutoFix)
        hasher.combine(isFirstRun)
        hasher.combine(binaryOk)
        hasher.combine(configOk)
        hasher.combine(firingOk)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHookDiagnosticReport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HookDiagnosticReport {
        return
            try HookDiagnosticReport(
                isHealthy: FfiConverterBool.read(from: &buf),
                primaryIssue: FfiConverterOptionTypeHookIssue.read(from: &buf),
                canAutoFix: FfiConverterBool.read(from: &buf),
                isFirstRun: FfiConverterBool.read(from: &buf),
                binaryOk: FfiConverterBool.read(from: &buf),
                configOk: FfiConverterBool.read(from: &buf),
                firingOk: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: HookDiagnosticReport, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isHealthy, into: &buf)
        FfiConverterOptionTypeHookIssue.write(value.primaryIssue, into: &buf)
        FfiConverterBool.write(value.canAutoFix, into: &buf)
        FfiConverterBool.write(value.isFirstRun, into: &buf)
        FfiConverterBool.write(value.binaryOk, into: &buf)
        FfiConverterBool.write(value.configOk, into: &buf)
        FfiConverterBool.write(value.firingOk, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookDiagnosticReport_lift(_ buf: RustBuffer) throws -> HookDiagnosticReport {
    return try FfiConverterTypeHookDiagnosticReport.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookDiagnosticReport_lower(_ value: HookDiagnosticReport) -> RustBuffer {
    return FfiConverterTypeHookDiagnosticReport.lower(value)
}

/**
 * Full health report for the hook binary.
 */
public struct HookHealthReport {
    public var status: HookHealthStatus
    public var heartbeatPath: String
    public var thresholdSecs: UInt64
    public var lastHeartbeatAgeSecs: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(status: HookHealthStatus, heartbeatPath: String, thresholdSecs: UInt64, lastHeartbeatAgeSecs: UInt64?) {
        self.status = status
        self.heartbeatPath = heartbeatPath
        self.thresholdSecs = thresholdSecs
        self.lastHeartbeatAgeSecs = lastHeartbeatAgeSecs
    }
}

extension HookHealthReport: Equatable, Hashable {
    public static func == (lhs: HookHealthReport, rhs: HookHealthReport) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.heartbeatPath != rhs.heartbeatPath {
            return false
        }
        if lhs.thresholdSecs != rhs.thresholdSecs {
            return false
        }
        if lhs.lastHeartbeatAgeSecs != rhs.lastHeartbeatAgeSecs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(heartbeatPath)
        hasher.combine(thresholdSecs)
        hasher.combine(lastHeartbeatAgeSecs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHookHealthReport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HookHealthReport {
        return
            try HookHealthReport(
                status: FfiConverterTypeHookHealthStatus.read(from: &buf),
                heartbeatPath: FfiConverterString.read(from: &buf),
                thresholdSecs: FfiConverterUInt64.read(from: &buf),
                lastHeartbeatAgeSecs: FfiConverterOptionUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: HookHealthReport, into buf: inout [UInt8]) {
        FfiConverterTypeHookHealthStatus.write(value.status, into: &buf)
        FfiConverterString.write(value.heartbeatPath, into: &buf)
        FfiConverterUInt64.write(value.thresholdSecs, into: &buf)
        FfiConverterOptionUInt64.write(value.lastHeartbeatAgeSecs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookHealthReport_lift(_ buf: RustBuffer) throws -> HookHealthReport {
    return try FfiConverterTypeHookHealthReport.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookHealthReport_lower(_ value: HookHealthReport) -> RustBuffer {
    return FfiConverterTypeHookHealthReport.lower(value)
}

/**
 * HUD configuration (pinned projects, etc.)
 */
public struct HudConfig {
    public var pinnedProjects: [String]
    public var terminalApp: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pinnedProjects: [String], terminalApp: String) {
        self.pinnedProjects = pinnedProjects
        self.terminalApp = terminalApp
    }
}

extension HudConfig: Equatable, Hashable {
    public static func == (lhs: HudConfig, rhs: HudConfig) -> Bool {
        if lhs.pinnedProjects != rhs.pinnedProjects {
            return false
        }
        if lhs.terminalApp != rhs.terminalApp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pinnedProjects)
        hasher.combine(terminalApp)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHudConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HudConfig {
        return
            try HudConfig(
                pinnedProjects: FfiConverterSequenceString.read(from: &buf),
                terminalApp: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: HudConfig, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.pinnedProjects, into: &buf)
        FfiConverterString.write(value.terminalApp, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHudConfig_lift(_ buf: RustBuffer) throws -> HudConfig {
    return try FfiConverterTypeHudConfig.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHudConfig_lower(_ value: HudConfig) -> RustBuffer {
    return FfiConverterTypeHudConfig.lower(value)
}

/**
 * A captured idea stored in `~/.capacitor/projects/{encoded}/ideas.md`.
 *
 * Ideas are stored in markdown format with ULID identifiers for stable references.
 * They can be in various states (open, in-progress, done) and have triage status.
 */
public struct Idea {
    /**
     * ULID identifier (26 chars, uppercase, sortable)
     */
    public var id: String
    /**
     * Short title extracted from first line
     */
    public var title: String
    /**
     * Full description text
     */
    public var description: String
    /**
     * ISO8601 timestamp when added
     */
    public var added: String
    /**
     * Effort estimate: unknown, small, medium, large, xl
     */
    public var effort: String
    /**
     * Status: open, in-progress, done
     */
    public var status: String
    /**
     * Triage status: pending, validated
     */
    public var triage: String
    /**
     * Related project name (if associated with a specific project)
     */
    public var related: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ULID identifier (26 chars, uppercase, sortable)
         */ id: String,
        /**
            * Short title extracted from first line
            */ title: String,
        /**
            * Full description text
            */ description: String,
        /**
            * ISO8601 timestamp when added
            */ added: String,
        /**
            * Effort estimate: unknown, small, medium, large, xl
            */ effort: String,
        /**
            * Status: open, in-progress, done
            */ status: String,
        /**
            * Triage status: pending, validated
            */ triage: String,
        /**
            * Related project name (if associated with a specific project)
            */ related: String?
    ) {
        self.id = id
        self.title = title
        self.description = description
        self.added = added
        self.effort = effort
        self.status = status
        self.triage = triage
        self.related = related
    }
}

extension Idea: Equatable, Hashable {
    public static func == (lhs: Idea, rhs: Idea) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.added != rhs.added {
            return false
        }
        if lhs.effort != rhs.effort {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.triage != rhs.triage {
            return false
        }
        if lhs.related != rhs.related {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(title)
        hasher.combine(description)
        hasher.combine(added)
        hasher.combine(effort)
        hasher.combine(status)
        hasher.combine(triage)
        hasher.combine(related)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdea: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Idea {
        return
            try Idea(
                id: FfiConverterString.read(from: &buf),
                title: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                added: FfiConverterString.read(from: &buf),
                effort: FfiConverterString.read(from: &buf),
                status: FfiConverterString.read(from: &buf),
                triage: FfiConverterString.read(from: &buf),
                related: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: Idea, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.added, into: &buf)
        FfiConverterString.write(value.effort, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterString.write(value.triage, into: &buf)
        FfiConverterOptionString.write(value.related, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeIdea_lift(_ buf: RustBuffer) throws -> Idea {
    return try FfiConverterTypeIdea.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeIdea_lower(_ value: Idea) -> RustBuffer {
    return FfiConverterTypeIdea.lower(value)
}

public struct InstallResult {
    public var success: Bool
    public var message: String
    public var scriptPath: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(success: Bool, message: String, scriptPath: String?) {
        self.success = success
        self.message = message
        self.scriptPath = scriptPath
    }
}

extension InstallResult: Equatable, Hashable {
    public static func == (lhs: InstallResult, rhs: InstallResult) -> Bool {
        if lhs.success != rhs.success {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.scriptPath != rhs.scriptPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(success)
        hasher.combine(message)
        hasher.combine(scriptPath)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeInstallResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InstallResult {
        return
            try InstallResult(
                success: FfiConverterBool.read(from: &buf),
                message: FfiConverterString.read(from: &buf),
                scriptPath: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: InstallResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.success, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterOptionString.write(value.scriptPath, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeInstallResult_lift(_ buf: RustBuffer) throws -> InstallResult {
    return try FfiConverterTypeInstallResult.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeInstallResult_lower(_ value: InstallResult) -> RustBuffer {
    return FfiConverterTypeInstallResult.lower(value)
}

/**
 * Request to create a new project from an idea.
 */
public struct NewProjectRequest {
    public var name: String
    public var description: String
    public var location: String
    public var language: String?
    public var framework: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, description: String, location: String, language: String?, framework: String?) {
        self.name = name
        self.description = description
        self.location = location
        self.language = language
        self.framework = framework
    }
}

extension NewProjectRequest: Equatable, Hashable {
    public static func == (lhs: NewProjectRequest, rhs: NewProjectRequest) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.location != rhs.location {
            return false
        }
        if lhs.language != rhs.language {
            return false
        }
        if lhs.framework != rhs.framework {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(location)
        hasher.combine(language)
        hasher.combine(framework)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNewProjectRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NewProjectRequest {
        return
            try NewProjectRequest(
                name: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                location: FfiConverterString.read(from: &buf),
                language: FfiConverterOptionString.read(from: &buf),
                framework: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: NewProjectRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.location, into: &buf)
        FfiConverterOptionString.write(value.language, into: &buf)
        FfiConverterOptionString.write(value.framework, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNewProjectRequest_lift(_ buf: RustBuffer) throws -> NewProjectRequest {
    return try FfiConverterTypeNewProjectRequest.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNewProjectRequest_lower(_ value: NewProjectRequest) -> RustBuffer {
    return FfiConverterTypeNewProjectRequest.lower(value)
}

/**
 * An installed Claude Code plugin.
 */
public struct Plugin {
    public var id: String
    public var name: String
    public var description: String
    public var enabled: Bool
    public var path: String
    public var skillCount: UInt32
    public var commandCount: UInt32
    public var agentCount: UInt32
    public var hookCount: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, description: String, enabled: Bool, path: String, skillCount: UInt32, commandCount: UInt32, agentCount: UInt32, hookCount: UInt32) {
        self.id = id
        self.name = name
        self.description = description
        self.enabled = enabled
        self.path = path
        self.skillCount = skillCount
        self.commandCount = commandCount
        self.agentCount = agentCount
        self.hookCount = hookCount
    }
}

extension Plugin: Equatable, Hashable {
    public static func == (lhs: Plugin, rhs: Plugin) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.enabled != rhs.enabled {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.skillCount != rhs.skillCount {
            return false
        }
        if lhs.commandCount != rhs.commandCount {
            return false
        }
        if lhs.agentCount != rhs.agentCount {
            return false
        }
        if lhs.hookCount != rhs.hookCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(enabled)
        hasher.combine(path)
        hasher.combine(skillCount)
        hasher.combine(commandCount)
        hasher.combine(agentCount)
        hasher.combine(hookCount)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePlugin: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Plugin {
        return
            try Plugin(
                id: FfiConverterString.read(from: &buf),
                name: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                enabled: FfiConverterBool.read(from: &buf),
                path: FfiConverterString.read(from: &buf),
                skillCount: FfiConverterUInt32.read(from: &buf),
                commandCount: FfiConverterUInt32.read(from: &buf),
                agentCount: FfiConverterUInt32.read(from: &buf),
                hookCount: FfiConverterUInt32.read(from: &buf)
            )
    }

    public static func write(_ value: Plugin, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterUInt32.write(value.skillCount, into: &buf)
        FfiConverterUInt32.write(value.commandCount, into: &buf)
        FfiConverterUInt32.write(value.agentCount, into: &buf)
        FfiConverterUInt32.write(value.hookCount, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePlugin_lift(_ buf: RustBuffer) throws -> Plugin {
    return try FfiConverterTypePlugin.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePlugin_lower(_ value: Plugin) -> RustBuffer {
    return FfiConverterTypePlugin.lower(value)
}

/**
 * Plugin manifest from plugin.json.
 */
public struct PluginManifest {
    public var name: String
    public var description: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, description: String?) {
        self.name = name
        self.description = description
    }
}

extension PluginManifest: Equatable, Hashable {
    public static func == (lhs: PluginManifest, rhs: PluginManifest) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(description)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePluginManifest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PluginManifest {
        return
            try PluginManifest(
                name: FfiConverterString.read(from: &buf),
                description: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: PluginManifest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePluginManifest_lift(_ buf: RustBuffer) throws -> PluginManifest {
    return try FfiConverterTypePluginManifest.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePluginManifest_lower(_ value: PluginManifest) -> RustBuffer {
    return FfiConverterTypePluginManifest.lower(value)
}

/**
 * A pinned project in the HUD.
 */
public struct Project {
    public var name: String
    public var path: String
    public var displayPath: String
    public var lastActive: String?
    public var claudeMdPath: String?
    public var claudeMdPreview: String?
    public var hasLocalSettings: Bool
    public var taskCount: UInt32
    public var stats: ProjectStats?
    /**
     * True if the project directory no longer exists on disk.
     */
    public var isMissing: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, path: String, displayPath: String, lastActive: String?, claudeMdPath: String?, claudeMdPreview: String?, hasLocalSettings: Bool, taskCount: UInt32, stats: ProjectStats?,
                /**
                    * True if the project directory no longer exists on disk.
                    */ isMissing: Bool)
    {
        self.name = name
        self.path = path
        self.displayPath = displayPath
        self.lastActive = lastActive
        self.claudeMdPath = claudeMdPath
        self.claudeMdPreview = claudeMdPreview
        self.hasLocalSettings = hasLocalSettings
        self.taskCount = taskCount
        self.stats = stats
        self.isMissing = isMissing
    }
}

extension Project: Equatable, Hashable {
    public static func == (lhs: Project, rhs: Project) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.displayPath != rhs.displayPath {
            return false
        }
        if lhs.lastActive != rhs.lastActive {
            return false
        }
        if lhs.claudeMdPath != rhs.claudeMdPath {
            return false
        }
        if lhs.claudeMdPreview != rhs.claudeMdPreview {
            return false
        }
        if lhs.hasLocalSettings != rhs.hasLocalSettings {
            return false
        }
        if lhs.taskCount != rhs.taskCount {
            return false
        }
        if lhs.stats != rhs.stats {
            return false
        }
        if lhs.isMissing != rhs.isMissing {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(path)
        hasher.combine(displayPath)
        hasher.combine(lastActive)
        hasher.combine(claudeMdPath)
        hasher.combine(claudeMdPreview)
        hasher.combine(hasLocalSettings)
        hasher.combine(taskCount)
        hasher.combine(stats)
        hasher.combine(isMissing)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeProject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Project {
        return
            try Project(
                name: FfiConverterString.read(from: &buf),
                path: FfiConverterString.read(from: &buf),
                displayPath: FfiConverterString.read(from: &buf),
                lastActive: FfiConverterOptionString.read(from: &buf),
                claudeMdPath: FfiConverterOptionString.read(from: &buf),
                claudeMdPreview: FfiConverterOptionString.read(from: &buf),
                hasLocalSettings: FfiConverterBool.read(from: &buf),
                taskCount: FfiConverterUInt32.read(from: &buf),
                stats: FfiConverterOptionTypeProjectStats.read(from: &buf),
                isMissing: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: Project, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.displayPath, into: &buf)
        FfiConverterOptionString.write(value.lastActive, into: &buf)
        FfiConverterOptionString.write(value.claudeMdPath, into: &buf)
        FfiConverterOptionString.write(value.claudeMdPreview, into: &buf)
        FfiConverterBool.write(value.hasLocalSettings, into: &buf)
        FfiConverterUInt32.write(value.taskCount, into: &buf)
        FfiConverterOptionTypeProjectStats.write(value.stats, into: &buf)
        FfiConverterBool.write(value.isMissing, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProject_lift(_ buf: RustBuffer) throws -> Project {
    return try FfiConverterTypeProject.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProject_lower(_ value: Project) -> RustBuffer {
    return FfiConverterTypeProject.lower(value)
}

/**
 * A project being created via the Idea  V1 flow.
 */
public struct ProjectCreation {
    public var id: String
    public var name: String
    public var path: String
    public var description: String
    public var status: CreationStatus
    public var sessionId: String?
    public var progress: CreationProgress?
    public var error: String?
    public var createdAt: String
    public var completedAt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, path: String, description: String, status: CreationStatus, sessionId: String?, progress: CreationProgress?, error: String?, createdAt: String, completedAt: String?) {
        self.id = id
        self.name = name
        self.path = path
        self.description = description
        self.status = status
        self.sessionId = sessionId
        self.progress = progress
        self.error = error
        self.createdAt = createdAt
        self.completedAt = completedAt
    }
}

extension ProjectCreation: Equatable, Hashable {
    public static func == (lhs: ProjectCreation, rhs: ProjectCreation) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.progress != rhs.progress {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.completedAt != rhs.completedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(path)
        hasher.combine(description)
        hasher.combine(status)
        hasher.combine(sessionId)
        hasher.combine(progress)
        hasher.combine(error)
        hasher.combine(createdAt)
        hasher.combine(completedAt)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeProjectCreation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProjectCreation {
        return
            try ProjectCreation(
                id: FfiConverterString.read(from: &buf),
                name: FfiConverterString.read(from: &buf),
                path: FfiConverterString.read(from: &buf),
                description: FfiConverterString.read(from: &buf),
                status: FfiConverterTypeCreationStatus.read(from: &buf),
                sessionId: FfiConverterOptionString.read(from: &buf),
                progress: FfiConverterOptionTypeCreationProgress.read(from: &buf),
                error: FfiConverterOptionString.read(from: &buf),
                createdAt: FfiConverterString.read(from: &buf),
                completedAt: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: ProjectCreation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterTypeCreationStatus.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.sessionId, into: &buf)
        FfiConverterOptionTypeCreationProgress.write(value.progress, into: &buf)
        FfiConverterOptionString.write(value.error, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterOptionString.write(value.completedAt, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectCreation_lift(_ buf: RustBuffer) throws -> ProjectCreation {
    return try FfiConverterTypeProjectCreation.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectCreation_lower(_ value: ProjectCreation) -> RustBuffer {
    return FfiConverterTypeProjectCreation.lower(value)
}

/**
 * Detailed project information including tasks and git status.
 */
public struct ProjectDetails {
    public var project: Project
    public var claudeMdContent: String?
    public var tasks: [Task]
    public var gitBranch: String?
    public var gitDirty: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(project: Project, claudeMdContent: String?, tasks: [Task], gitBranch: String?, gitDirty: Bool) {
        self.project = project
        self.claudeMdContent = claudeMdContent
        self.tasks = tasks
        self.gitBranch = gitBranch
        self.gitDirty = gitDirty
    }
}

extension ProjectDetails: Equatable, Hashable {
    public static func == (lhs: ProjectDetails, rhs: ProjectDetails) -> Bool {
        if lhs.project != rhs.project {
            return false
        }
        if lhs.claudeMdContent != rhs.claudeMdContent {
            return false
        }
        if lhs.tasks != rhs.tasks {
            return false
        }
        if lhs.gitBranch != rhs.gitBranch {
            return false
        }
        if lhs.gitDirty != rhs.gitDirty {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(project)
        hasher.combine(claudeMdContent)
        hasher.combine(tasks)
        hasher.combine(gitBranch)
        hasher.combine(gitDirty)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeProjectDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProjectDetails {
        return
            try ProjectDetails(
                project: FfiConverterTypeProject.read(from: &buf),
                claudeMdContent: FfiConverterOptionString.read(from: &buf),
                tasks: FfiConverterSequenceTypeTask.read(from: &buf),
                gitBranch: FfiConverterOptionString.read(from: &buf),
                gitDirty: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: ProjectDetails, into buf: inout [UInt8]) {
        FfiConverterTypeProject.write(value.project, into: &buf)
        FfiConverterOptionString.write(value.claudeMdContent, into: &buf)
        FfiConverterSequenceTypeTask.write(value.tasks, into: &buf)
        FfiConverterOptionString.write(value.gitBranch, into: &buf)
        FfiConverterBool.write(value.gitDirty, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectDetails_lift(_ buf: RustBuffer) throws -> ProjectDetails {
    return try FfiConverterTypeProjectDetails.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectDetails_lower(_ value: ProjectDetails) -> RustBuffer {
    return FfiConverterTypeProjectDetails.lower(value)
}

/**
 * Full session state with context information.
 */
public struct ProjectSessionState {
    public var state: SessionState
    public var stateChangedAt: String?
    /**
     * Timestamp of last hook event (more recent than state_changed_at).
     * Use this for activity comparison between sessions.
     */
    public var updatedAt: String?
    public var sessionId: String?
    public var workingOn: String?
    public var context: ContextInfo?
    /**
     * Whether Claude is currently "thinking" (API call in flight).
     * This provides real-time status when using the fetch-intercepting launcher.
     */
    public var thinking: Bool?
    /**
     * Whether a lock file is held for this project (indicates Claude is running).
     * This is checked via advisory file locks and is more reliable than state file alone.
     */
    public var isLocked: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: SessionState, stateChangedAt: String?,
                /**
                    * Timestamp of last hook event (more recent than state_changed_at).
                    * Use this for activity comparison between sessions.
                    */ updatedAt: String?, sessionId: String?, workingOn: String?, context: ContextInfo?,
                /**
                    * Whether Claude is currently "thinking" (API call in flight).
                    * This provides real-time status when using the fetch-intercepting launcher.
                    */ thinking: Bool?,
                /**
                    * Whether a lock file is held for this project (indicates Claude is running).
                    * This is checked via advisory file locks and is more reliable than state file alone.
                    */ isLocked: Bool)
    {
        self.state = state
        self.stateChangedAt = stateChangedAt
        self.updatedAt = updatedAt
        self.sessionId = sessionId
        self.workingOn = workingOn
        self.context = context
        self.thinking = thinking
        self.isLocked = isLocked
    }
}

extension ProjectSessionState: Equatable, Hashable {
    public static func == (lhs: ProjectSessionState, rhs: ProjectSessionState) -> Bool {
        if lhs.state != rhs.state {
            return false
        }
        if lhs.stateChangedAt != rhs.stateChangedAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.sessionId != rhs.sessionId {
            return false
        }
        if lhs.workingOn != rhs.workingOn {
            return false
        }
        if lhs.context != rhs.context {
            return false
        }
        if lhs.thinking != rhs.thinking {
            return false
        }
        if lhs.isLocked != rhs.isLocked {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(state)
        hasher.combine(stateChangedAt)
        hasher.combine(updatedAt)
        hasher.combine(sessionId)
        hasher.combine(workingOn)
        hasher.combine(context)
        hasher.combine(thinking)
        hasher.combine(isLocked)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeProjectSessionState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProjectSessionState {
        return
            try ProjectSessionState(
                state: FfiConverterTypeSessionState.read(from: &buf),
                stateChangedAt: FfiConverterOptionString.read(from: &buf),
                updatedAt: FfiConverterOptionString.read(from: &buf),
                sessionId: FfiConverterOptionString.read(from: &buf),
                workingOn: FfiConverterOptionString.read(from: &buf),
                context: FfiConverterOptionTypeContextInfo.read(from: &buf),
                thinking: FfiConverterOptionBool.read(from: &buf),
                isLocked: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: ProjectSessionState, into buf: inout [UInt8]) {
        FfiConverterTypeSessionState.write(value.state, into: &buf)
        FfiConverterOptionString.write(value.stateChangedAt, into: &buf)
        FfiConverterOptionString.write(value.updatedAt, into: &buf)
        FfiConverterOptionString.write(value.sessionId, into: &buf)
        FfiConverterOptionString.write(value.workingOn, into: &buf)
        FfiConverterOptionTypeContextInfo.write(value.context, into: &buf)
        FfiConverterOptionBool.write(value.thinking, into: &buf)
        FfiConverterBool.write(value.isLocked, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectSessionState_lift(_ buf: RustBuffer) throws -> ProjectSessionState {
    return try FfiConverterTypeProjectSessionState.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectSessionState_lower(_ value: ProjectSessionState) -> RustBuffer {
    return FfiConverterTypeProjectSessionState.lower(value)
}

/**
 * Aggregated token usage statistics for a project.
 */
public struct ProjectStats {
    public var totalInputTokens: UInt64
    public var totalOutputTokens: UInt64
    public var totalCacheReadTokens: UInt64
    public var totalCacheCreationTokens: UInt64
    public var opusMessages: UInt32
    public var sonnetMessages: UInt32
    public var haikuMessages: UInt32
    public var sessionCount: UInt32
    public var latestSummary: String?
    public var firstActivity: String?
    public var lastActivity: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(totalInputTokens: UInt64, totalOutputTokens: UInt64, totalCacheReadTokens: UInt64, totalCacheCreationTokens: UInt64, opusMessages: UInt32, sonnetMessages: UInt32, haikuMessages: UInt32, sessionCount: UInt32, latestSummary: String?, firstActivity: String?, lastActivity: String?) {
        self.totalInputTokens = totalInputTokens
        self.totalOutputTokens = totalOutputTokens
        self.totalCacheReadTokens = totalCacheReadTokens
        self.totalCacheCreationTokens = totalCacheCreationTokens
        self.opusMessages = opusMessages
        self.sonnetMessages = sonnetMessages
        self.haikuMessages = haikuMessages
        self.sessionCount = sessionCount
        self.latestSummary = latestSummary
        self.firstActivity = firstActivity
        self.lastActivity = lastActivity
    }
}

extension ProjectStats: Equatable, Hashable {
    public static func == (lhs: ProjectStats, rhs: ProjectStats) -> Bool {
        if lhs.totalInputTokens != rhs.totalInputTokens {
            return false
        }
        if lhs.totalOutputTokens != rhs.totalOutputTokens {
            return false
        }
        if lhs.totalCacheReadTokens != rhs.totalCacheReadTokens {
            return false
        }
        if lhs.totalCacheCreationTokens != rhs.totalCacheCreationTokens {
            return false
        }
        if lhs.opusMessages != rhs.opusMessages {
            return false
        }
        if lhs.sonnetMessages != rhs.sonnetMessages {
            return false
        }
        if lhs.haikuMessages != rhs.haikuMessages {
            return false
        }
        if lhs.sessionCount != rhs.sessionCount {
            return false
        }
        if lhs.latestSummary != rhs.latestSummary {
            return false
        }
        if lhs.firstActivity != rhs.firstActivity {
            return false
        }
        if lhs.lastActivity != rhs.lastActivity {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(totalInputTokens)
        hasher.combine(totalOutputTokens)
        hasher.combine(totalCacheReadTokens)
        hasher.combine(totalCacheCreationTokens)
        hasher.combine(opusMessages)
        hasher.combine(sonnetMessages)
        hasher.combine(haikuMessages)
        hasher.combine(sessionCount)
        hasher.combine(latestSummary)
        hasher.combine(firstActivity)
        hasher.combine(lastActivity)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeProjectStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProjectStats {
        return
            try ProjectStats(
                totalInputTokens: FfiConverterUInt64.read(from: &buf),
                totalOutputTokens: FfiConverterUInt64.read(from: &buf),
                totalCacheReadTokens: FfiConverterUInt64.read(from: &buf),
                totalCacheCreationTokens: FfiConverterUInt64.read(from: &buf),
                opusMessages: FfiConverterUInt32.read(from: &buf),
                sonnetMessages: FfiConverterUInt32.read(from: &buf),
                haikuMessages: FfiConverterUInt32.read(from: &buf),
                sessionCount: FfiConverterUInt32.read(from: &buf),
                latestSummary: FfiConverterOptionString.read(from: &buf),
                firstActivity: FfiConverterOptionString.read(from: &buf),
                lastActivity: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: ProjectStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.totalInputTokens, into: &buf)
        FfiConverterUInt64.write(value.totalOutputTokens, into: &buf)
        FfiConverterUInt64.write(value.totalCacheReadTokens, into: &buf)
        FfiConverterUInt64.write(value.totalCacheCreationTokens, into: &buf)
        FfiConverterUInt32.write(value.opusMessages, into: &buf)
        FfiConverterUInt32.write(value.sonnetMessages, into: &buf)
        FfiConverterUInt32.write(value.haikuMessages, into: &buf)
        FfiConverterUInt32.write(value.sessionCount, into: &buf)
        FfiConverterOptionString.write(value.latestSummary, into: &buf)
        FfiConverterOptionString.write(value.firstActivity, into: &buf)
        FfiConverterOptionString.write(value.lastActivity, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectStats_lift(_ buf: RustBuffer) throws -> ProjectStats {
    return try FfiConverterTypeProjectStats.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectStats_lower(_ value: ProjectStats) -> RustBuffer {
    return FfiConverterTypeProjectStats.lower(value)
}

/**
 * Project status as stored in .claude/hud-status.json within each project.
 */
public struct ProjectStatus {
    public var workingOn: String?
    public var nextStep: String?
    public var status: String?
    public var blocker: String?
    public var updatedAt: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(workingOn: String?, nextStep: String?, status: String?, blocker: String?, updatedAt: String?) {
        self.workingOn = workingOn
        self.nextStep = nextStep
        self.status = status
        self.blocker = blocker
        self.updatedAt = updatedAt
    }
}

extension ProjectStatus: Equatable, Hashable {
    public static func == (lhs: ProjectStatus, rhs: ProjectStatus) -> Bool {
        if lhs.workingOn != rhs.workingOn {
            return false
        }
        if lhs.nextStep != rhs.nextStep {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.blocker != rhs.blocker {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(workingOn)
        hasher.combine(nextStep)
        hasher.combine(status)
        hasher.combine(blocker)
        hasher.combine(updatedAt)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeProjectStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProjectStatus {
        return
            try ProjectStatus(
                workingOn: FfiConverterOptionString.read(from: &buf),
                nextStep: FfiConverterOptionString.read(from: &buf),
                status: FfiConverterOptionString.read(from: &buf),
                blocker: FfiConverterOptionString.read(from: &buf),
                updatedAt: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: ProjectStatus, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.workingOn, into: &buf)
        FfiConverterOptionString.write(value.nextStep, into: &buf)
        FfiConverterOptionString.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.blocker, into: &buf)
        FfiConverterOptionString.write(value.updatedAt, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectStatus_lift(_ buf: RustBuffer) throws -> ProjectStatus {
    return try FfiConverterTypeProjectStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeProjectStatus_lower(_ value: ProjectStatus) -> RustBuffer {
    return FfiConverterTypeProjectStatus.lower(value)
}

public struct SetupStatus {
    public var dependencies: [DependencyStatus]
    public var hooks: HookStatus
    public var storageReady: Bool
    public var allReady: Bool
    public var blockingReason: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(dependencies: [DependencyStatus], hooks: HookStatus, storageReady: Bool, allReady: Bool, blockingReason: String?) {
        self.dependencies = dependencies
        self.hooks = hooks
        self.storageReady = storageReady
        self.allReady = allReady
        self.blockingReason = blockingReason
    }
}

extension SetupStatus: Equatable, Hashable {
    public static func == (lhs: SetupStatus, rhs: SetupStatus) -> Bool {
        if lhs.dependencies != rhs.dependencies {
            return false
        }
        if lhs.hooks != rhs.hooks {
            return false
        }
        if lhs.storageReady != rhs.storageReady {
            return false
        }
        if lhs.allReady != rhs.allReady {
            return false
        }
        if lhs.blockingReason != rhs.blockingReason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(dependencies)
        hasher.combine(hooks)
        hasher.combine(storageReady)
        hasher.combine(allReady)
        hasher.combine(blockingReason)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSetupStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SetupStatus {
        return
            try SetupStatus(
                dependencies: FfiConverterSequenceTypeDependencyStatus.read(from: &buf),
                hooks: FfiConverterTypeHookStatus.read(from: &buf),
                storageReady: FfiConverterBool.read(from: &buf),
                allReady: FfiConverterBool.read(from: &buf),
                blockingReason: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: SetupStatus, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeDependencyStatus.write(value.dependencies, into: &buf)
        FfiConverterTypeHookStatus.write(value.hooks, into: &buf)
        FfiConverterBool.write(value.storageReady, into: &buf)
        FfiConverterBool.write(value.allReady, into: &buf)
        FfiConverterOptionString.write(value.blockingReason, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSetupStatus_lift(_ buf: RustBuffer) throws -> SetupStatus {
    return try FfiConverterTypeSetupStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSetupStatus_lower(_ value: SetupStatus) -> RustBuffer {
    return FfiConverterTypeSetupStatus.lower(value)
}

/**
 * The full stats cache, persisted to disk.
 */
public struct StatsCache {
    public var projects: [String: CachedProjectStats]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(projects: [String: CachedProjectStats]) {
        self.projects = projects
    }
}

extension StatsCache: Equatable, Hashable {
    public static func == (lhs: StatsCache, rhs: StatsCache) -> Bool {
        if lhs.projects != rhs.projects {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(projects)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeStatsCache: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StatsCache {
        return
            try StatsCache(
                projects: FfiConverterDictionaryStringTypeCachedProjectStats.read(from: &buf)
            )
    }

    public static func write(_ value: StatsCache, into buf: inout [UInt8]) {
        FfiConverterDictionaryStringTypeCachedProjectStats.write(value.projects, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeStatsCache_lift(_ buf: RustBuffer) throws -> StatsCache {
    return try FfiConverterTypeStatsCache.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeStatsCache_lower(_ value: StatsCache) -> RustBuffer {
    return FfiConverterTypeStatsCache.lower(value)
}

/**
 * A project discovered in `~/.claude/projects/` but not yet pinned.
 */
public struct SuggestedProject {
    public var path: String
    public var displayPath: String
    public var name: String
    public var taskCount: UInt32
    public var hasClaudeMd: Bool
    public var hasProjectIndicators: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: String, displayPath: String, name: String, taskCount: UInt32, hasClaudeMd: Bool, hasProjectIndicators: Bool) {
        self.path = path
        self.displayPath = displayPath
        self.name = name
        self.taskCount = taskCount
        self.hasClaudeMd = hasClaudeMd
        self.hasProjectIndicators = hasProjectIndicators
    }
}

extension SuggestedProject: Equatable, Hashable {
    public static func == (lhs: SuggestedProject, rhs: SuggestedProject) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.displayPath != rhs.displayPath {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.taskCount != rhs.taskCount {
            return false
        }
        if lhs.hasClaudeMd != rhs.hasClaudeMd {
            return false
        }
        if lhs.hasProjectIndicators != rhs.hasProjectIndicators {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(displayPath)
        hasher.combine(name)
        hasher.combine(taskCount)
        hasher.combine(hasClaudeMd)
        hasher.combine(hasProjectIndicators)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSuggestedProject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuggestedProject {
        return
            try SuggestedProject(
                path: FfiConverterString.read(from: &buf),
                displayPath: FfiConverterString.read(from: &buf),
                name: FfiConverterString.read(from: &buf),
                taskCount: FfiConverterUInt32.read(from: &buf),
                hasClaudeMd: FfiConverterBool.read(from: &buf),
                hasProjectIndicators: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: SuggestedProject, into buf: inout [UInt8]) {
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.displayPath, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt32.write(value.taskCount, into: &buf)
        FfiConverterBool.write(value.hasClaudeMd, into: &buf)
        FfiConverterBool.write(value.hasProjectIndicators, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSuggestedProject_lift(_ buf: RustBuffer) throws -> SuggestedProject {
    return try FfiConverterTypeSuggestedProject.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSuggestedProject_lower(_ value: SuggestedProject) -> RustBuffer {
    return FfiConverterTypeSuggestedProject.lower(value)
}

/**
 * A task/session from a project (represents Claude Code sessions).
 */
public struct Task {
    public var id: String
    public var name: String
    public var path: String
    public var lastModified: String
    public var summary: String?
    public var firstMessage: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, path: String, lastModified: String, summary: String?, firstMessage: String?) {
        self.id = id
        self.name = name
        self.path = path
        self.lastModified = lastModified
        self.summary = summary
        self.firstMessage = firstMessage
    }
}

extension Task: Equatable, Hashable {
    public static func == (lhs: Task, rhs: Task) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.lastModified != rhs.lastModified {
            return false
        }
        if lhs.summary != rhs.summary {
            return false
        }
        if lhs.firstMessage != rhs.firstMessage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(path)
        hasher.combine(lastModified)
        hasher.combine(summary)
        hasher.combine(firstMessage)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeTask: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Task {
        return
            try Task(
                id: FfiConverterString.read(from: &buf),
                name: FfiConverterString.read(from: &buf),
                path: FfiConverterString.read(from: &buf),
                lastModified: FfiConverterString.read(from: &buf),
                summary: FfiConverterOptionString.read(from: &buf),
                firstMessage: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: Task, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.lastModified, into: &buf)
        FfiConverterOptionString.write(value.summary, into: &buf)
        FfiConverterOptionString.write(value.firstMessage, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTask_lift(_ buf: RustBuffer) throws -> Task {
    return try FfiConverterTypeTask.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeTask_lower(_ value: Task) -> RustBuffer {
    return FfiConverterTypeTask.lower(value)
}

/**
 * FFI-friendly validation result for Swift/Kotlin/Python.
 *
 * Uses flat structure instead of enum variants for better FFI compatibility.
 */
public struct ValidationResultFfi {
    /**
     * Result type: "valid", "suggest_parent", "missing_claude_md", "not_a_project", "path_not_found", "dangerous_path"
     */
    public var resultType: String
    /**
     * The path (canonical or as provided, depending on result type)
     */
    public var path: String
    /**
     * For suggest_parent: the suggested project path
     */
    public var suggestedPath: String?
    /**
     * Human-readable reason for the result
     */
    public var reason: String?
    /**
     * Whether the project has a CLAUDE.md file
     */
    public var hasClaudeMd: Bool
    /**
     * Whether the project has other markers (.git, package.json, etc.)
     */
    public var hasOtherMarkers: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Result type: "valid", "suggest_parent", "missing_claude_md", "not_a_project", "path_not_found", "dangerous_path"
         */ resultType: String,
        /**
            * The path (canonical or as provided, depending on result type)
            */ path: String,
        /**
            * For suggest_parent: the suggested project path
            */ suggestedPath: String?,
        /**
            * Human-readable reason for the result
            */ reason: String?,
        /**
            * Whether the project has a CLAUDE.md file
            */ hasClaudeMd: Bool,
        /**
            * Whether the project has other markers (.git, package.json, etc.)
            */ hasOtherMarkers: Bool
    ) {
        self.resultType = resultType
        self.path = path
        self.suggestedPath = suggestedPath
        self.reason = reason
        self.hasClaudeMd = hasClaudeMd
        self.hasOtherMarkers = hasOtherMarkers
    }
}

extension ValidationResultFfi: Equatable, Hashable {
    public static func == (lhs: ValidationResultFfi, rhs: ValidationResultFfi) -> Bool {
        if lhs.resultType != rhs.resultType {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.suggestedPath != rhs.suggestedPath {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.hasClaudeMd != rhs.hasClaudeMd {
            return false
        }
        if lhs.hasOtherMarkers != rhs.hasOtherMarkers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(resultType)
        hasher.combine(path)
        hasher.combine(suggestedPath)
        hasher.combine(reason)
        hasher.combine(hasClaudeMd)
        hasher.combine(hasOtherMarkers)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeValidationResultFfi: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidationResultFfi {
        return
            try ValidationResultFfi(
                resultType: FfiConverterString.read(from: &buf),
                path: FfiConverterString.read(from: &buf),
                suggestedPath: FfiConverterOptionString.read(from: &buf),
                reason: FfiConverterOptionString.read(from: &buf),
                hasClaudeMd: FfiConverterBool.read(from: &buf),
                hasOtherMarkers: FfiConverterBool.read(from: &buf)
            )
    }

    public static func write(_ value: ValidationResultFfi, into buf: inout [UInt8]) {
        FfiConverterString.write(value.resultType, into: &buf)
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterOptionString.write(value.suggestedPath, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
        FfiConverterBool.write(value.hasClaudeMd, into: &buf)
        FfiConverterBool.write(value.hasOtherMarkers, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationResultFfi_lift(_ buf: RustBuffer) throws -> ValidationResultFfi {
    return try FfiConverterTypeValidationResultFfi.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeValidationResultFfi_lower(_ value: ValidationResultFfi) -> RustBuffer {
    return FfiConverterTypeValidationResultFfi.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Universal agent states - maps to any CLI agent's activity
 */

public enum AgentState {
    case idle
    case ready
    case working
    case waiting
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAgentState: FfiConverterRustBuffer {
    typealias SwiftType = AgentState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AgentState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .idle

        case 2: return .ready

        case 3: return .working

        case 4: return .waiting

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AgentState, into buf: inout [UInt8]) {
        switch value {
        case .idle:
            writeInt(&buf, Int32(1))

        case .ready:
            writeInt(&buf, Int32(2))

        case .working:
            writeInt(&buf, Int32(3))

        case .waiting:
            writeInt(&buf, Int32(4))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAgentState_lift(_ buf: RustBuffer) throws -> AgentState {
    return try FfiConverterTypeAgentState.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAgentState_lower(_ value: AgentState) -> RustBuffer {
    return FfiConverterTypeAgentState.lower(value)
}

extension AgentState: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Known agent types - flat enum for UniFFI compatibility
 */

public enum AgentType {
    case claude
    case codex
    case aider
    case amp
    case openCode
    case droid
    case other
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAgentType: FfiConverterRustBuffer {
    typealias SwiftType = AgentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AgentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .claude

        case 2: return .codex

        case 3: return .aider

        case 4: return .amp

        case 5: return .openCode

        case 6: return .droid

        case 7: return .other

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AgentType, into buf: inout [UInt8]) {
        switch value {
        case .claude:
            writeInt(&buf, Int32(1))

        case .codex:
            writeInt(&buf, Int32(2))

        case .aider:
            writeInt(&buf, Int32(3))

        case .amp:
            writeInt(&buf, Int32(4))

        case .openCode:
            writeInt(&buf, Int32(5))

        case .droid:
            writeInt(&buf, Int32(6))

        case .other:
            writeInt(&buf, Int32(7))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAgentType_lift(_ buf: RustBuffer) throws -> AgentType {
    return try FfiConverterTypeAgentType.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAgentType_lower(_ value: AgentType) -> RustBuffer {
    return FfiConverterTypeAgentType.lower(value)
}

extension AgentType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Status of a project creation.
 */

public enum CreationStatus {
    case pending
    case inProgress
    case completed
    case failed
    case cancelled
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreationStatus: FfiConverterRustBuffer {
    typealias SwiftType = CreationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .pending

        case 2: return .inProgress

        case 3: return .completed

        case 4: return .failed

        case 5: return .cancelled

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CreationStatus, into buf: inout [UInt8]) {
        switch value {
        case .pending:
            writeInt(&buf, Int32(1))

        case .inProgress:
            writeInt(&buf, Int32(2))

        case .completed:
            writeInt(&buf, Int32(3))

        case .failed:
            writeInt(&buf, Int32(4))

        case .cancelled:
            writeInt(&buf, Int32(5))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCreationStatus_lift(_ buf: RustBuffer) throws -> CreationStatus {
    return try FfiConverterTypeCreationStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeCreationStatus_lower(_ value: CreationStatus) -> RustBuffer {
    return FfiConverterTypeCreationStatus.lower(value)
}

extension CreationStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The health status of the hook binary based on heartbeat freshness.
 */

public enum HookHealthStatus {
    /**
     * Hooks are firing normally (heartbeat within threshold)
     */
    case healthy
    /**
     * No heartbeat file exists (hooks never fired or file deleted)
     */
    case unknown
    /**
     * Heartbeat is stale (hooks stopped firing)
     */
    case stale(lastSeenSecs: UInt64
    )
    /**
     * Heartbeat file exists but can't be read
     */
    case unreadable(reason: String
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHookHealthStatus: FfiConverterRustBuffer {
    typealias SwiftType = HookHealthStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HookHealthStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .healthy

        case 2: return .unknown

        case 3: return try .stale(lastSeenSecs: FfiConverterUInt64.read(from: &buf)
            )

        case 4: return try .unreadable(reason: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HookHealthStatus, into buf: inout [UInt8]) {
        switch value {
        case .healthy:
            writeInt(&buf, Int32(1))

        case .unknown:
            writeInt(&buf, Int32(2))

        case let .stale(lastSeenSecs):
            writeInt(&buf, Int32(3))
            FfiConverterUInt64.write(lastSeenSecs, into: &buf)

        case let .unreadable(reason):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(reason, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookHealthStatus_lift(_ buf: RustBuffer) throws -> HookHealthStatus {
    return try FfiConverterTypeHookHealthStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookHealthStatus_lower(_ value: HookHealthStatus) -> RustBuffer {
    return FfiConverterTypeHookHealthStatus.lower(value)
}

extension HookHealthStatus: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The primary issue preventing hooks from working correctly.
 *
 * Issues are prioritized: policy blocks are shown first (can't auto-fix),
 * then installation issues, then runtime issues.
 */

public enum HookIssue {
    /**
     * Hooks disabled by policy (disableAllHooks or allowManagedHooksOnly)
     */
    case policyBlocked(reason: String
    )
    /**
     * The hud-hook binary is not installed
     */
    case binaryMissing
    /**
     * The hud-hook binary exists but crashes (e.g., macOS codesigning)
     */
    case binaryBroken(reason: String
    )
    /**
     * The hud-hook symlink exists but points to a missing target (app moved, cargo clean, etc.)
     */
    case symlinkBroken(target: String, reason: String)
    /**
     * Hook configuration missing or incomplete in settings.json
     */
    case configMissing
    /**
     * Hook script/binary version is outdated
     */
    case configOutdated(current: String, latest: String)
    /**
     * Hooks are installed but not firing (heartbeat stale or missing)
     */
    case notFiring(lastSeenSecs: UInt64?
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHookIssue: FfiConverterRustBuffer {
    typealias SwiftType = HookIssue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HookIssue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .policyBlocked(reason: FfiConverterString.read(from: &buf)
            )

        case 2: return .binaryMissing

        case 3: return try .binaryBroken(reason: FfiConverterString.read(from: &buf)
            )

        case 4: return try .symlinkBroken(target: FfiConverterString.read(from: &buf), reason: FfiConverterString.read(from: &buf))

        case 5: return .configMissing

        case 6: return try .configOutdated(current: FfiConverterString.read(from: &buf), latest: FfiConverterString.read(from: &buf))

        case 7: return try .notFiring(lastSeenSecs: FfiConverterOptionUInt64.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HookIssue, into buf: inout [UInt8]) {
        switch value {
        case let .policyBlocked(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)

        case .binaryMissing:
            writeInt(&buf, Int32(2))

        case let .binaryBroken(reason):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(reason, into: &buf)

        case let .symlinkBroken(target, reason):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(target, into: &buf)
            FfiConverterString.write(reason, into: &buf)

        case .configMissing:
            writeInt(&buf, Int32(5))

        case let .configOutdated(current, latest):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(current, into: &buf)
            FfiConverterString.write(latest, into: &buf)

        case let .notFiring(lastSeenSecs):
            writeInt(&buf, Int32(7))
            FfiConverterOptionUInt64.write(lastSeenSecs, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookIssue_lift(_ buf: RustBuffer) throws -> HookIssue {
    return try FfiConverterTypeHookIssue.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookIssue_lower(_ value: HookIssue) -> RustBuffer {
    return FfiConverterTypeHookIssue.lower(value)
}

extension HookIssue: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HookStatus {
    case notInstalled
    case outdated(current: String, latest: String)
    case installed(version: String
    )
    case policyBlocked(reason: String
    )
    case binaryBroken(reason: String
    )
    /**
     * Symlink exists but target is missing (e.g., app moved or repo cleaned)
     */
    case symlinkBroken(target: String, reason: String)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHookStatus: FfiConverterRustBuffer {
    typealias SwiftType = HookStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HookStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .notInstalled

        case 2: return try .outdated(current: FfiConverterString.read(from: &buf), latest: FfiConverterString.read(from: &buf))

        case 3: return try .installed(version: FfiConverterString.read(from: &buf)
            )

        case 4: return try .policyBlocked(reason: FfiConverterString.read(from: &buf)
            )

        case 5: return try .binaryBroken(reason: FfiConverterString.read(from: &buf)
            )

        case 6: return try .symlinkBroken(target: FfiConverterString.read(from: &buf), reason: FfiConverterString.read(from: &buf))

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HookStatus, into buf: inout [UInt8]) {
        switch value {
        case .notInstalled:
            writeInt(&buf, Int32(1))

        case let .outdated(current, latest):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(current, into: &buf)
            FfiConverterString.write(latest, into: &buf)

        case let .installed(version):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(version, into: &buf)

        case let .policyBlocked(reason):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(reason, into: &buf)

        case let .binaryBroken(reason):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(reason, into: &buf)

        case let .symlinkBroken(target, reason):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(target, into: &buf)
            FfiConverterString.write(reason, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookStatus_lift(_ buf: RustBuffer) throws -> HookStatus {
    return try FfiConverterTypeHookStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHookStatus_lower(_ value: HookStatus) -> RustBuffer {
    return FfiConverterTypeHookStatus.lower(value)
}

extension HookStatus: Equatable, Hashable {}

/**
 * FFI-safe error type for use across language boundaries.
 *
 * This simplified error type contains just an error message string,
 * making it compatible with UniFFI's error handling.
 */
public enum HudFfiError {
    case General(message: String
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHudFfiError: FfiConverterRustBuffer {
    typealias SwiftType = HudFfiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HudFfiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .General(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HudFfiError, into buf: inout [UInt8]) {
        switch value {
        case let .General(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        }
    }
}

extension HudFfiError: Equatable, Hashable {}

extension HudFfiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The parent application hosting a shell session.
 *
 * This is the authoritative enum for app identification, exported via UniFFI
 * to Swift. All app classification logic should use this type rather than
 * parsing strings directly.
 *
 * **JSON serialization:** Uses lowercase strings (e.g., `ParentApp::ITerm`  `"iterm2"`)
 * for backward compatibility with existing `shell-cwd.json` files.
 */

public enum ParentApp {
    case ghostty
    case iTerm
    case terminal
    case alacritty
    case kitty
    case warp
    case cursor
    case vsCode
    case vsCodeInsiders
    case zed
    case tmux
    case unknown
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeParentApp: FfiConverterRustBuffer {
    typealias SwiftType = ParentApp

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParentApp {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .ghostty

        case 2: return .iTerm

        case 3: return .terminal

        case 4: return .alacritty

        case 5: return .kitty

        case 6: return .warp

        case 7: return .cursor

        case 8: return .vsCode

        case 9: return .vsCodeInsiders

        case 10: return .zed

        case 11: return .tmux

        case 12: return .unknown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParentApp, into buf: inout [UInt8]) {
        switch value {
        case .ghostty:
            writeInt(&buf, Int32(1))

        case .iTerm:
            writeInt(&buf, Int32(2))

        case .terminal:
            writeInt(&buf, Int32(3))

        case .alacritty:
            writeInt(&buf, Int32(4))

        case .kitty:
            writeInt(&buf, Int32(5))

        case .warp:
            writeInt(&buf, Int32(6))

        case .cursor:
            writeInt(&buf, Int32(7))

        case .vsCode:
            writeInt(&buf, Int32(8))

        case .vsCodeInsiders:
            writeInt(&buf, Int32(9))

        case .zed:
            writeInt(&buf, Int32(10))

        case .tmux:
            writeInt(&buf, Int32(11))

        case .unknown:
            writeInt(&buf, Int32(12))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeParentApp_lift(_ buf: RustBuffer) throws -> ParentApp {
    return try FfiConverterTypeParentApp.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeParentApp_lower(_ value: ParentApp) -> RustBuffer {
    return FfiConverterTypeParentApp.lower(value)
}

extension ParentApp: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The current state of a Claude Code session.
 */

public enum SessionState {
    case working
    case ready
    case idle
    case compacting
    case waiting
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionState: FfiConverterRustBuffer {
    typealias SwiftType = SessionState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .working

        case 2: return .ready

        case 3: return .idle

        case 4: return .compacting

        case 5: return .waiting

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionState, into buf: inout [UInt8]) {
        switch value {
        case .working:
            writeInt(&buf, Int32(1))

        case .ready:
            writeInt(&buf, Int32(2))

        case .idle:
            writeInt(&buf, Int32(3))

        case .compacting:
            writeInt(&buf, Int32(4))

        case .waiting:
            writeInt(&buf, Int32(5))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionState_lift(_ buf: RustBuffer) throws -> SessionState {
    return try FfiConverterTypeSessionState.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionState_lower(_ value: SessionState) -> RustBuffer {
    return FfiConverterTypeSessionState.lower(value)
}

extension SessionState: Equatable, Hashable {}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeAgentSession: FfiConverterRustBuffer {
    typealias SwiftType = AgentSession?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAgentSession.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAgentSession.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeContextInfo: FfiConverterRustBuffer {
    typealias SwiftType = ContextInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeContextInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeContextInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeCreationProgress: FfiConverterRustBuffer {
    typealias SwiftType = CreationProgress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCreationProgress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCreationProgress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeProjectStats: FfiConverterRustBuffer {
    typealias SwiftType = ProjectStats?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeProjectStats.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeProjectStats.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeProjectStatus: FfiConverterRustBuffer {
    typealias SwiftType = ProjectStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeProjectStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeProjectStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeHookIssue: FfiConverterRustBuffer {
    typealias SwiftType = HookIssue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHookIssue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHookIssue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeAgentSession: FfiConverterRustBuffer {
    typealias SwiftType = [AgentSession]

    public static func write(_ value: [AgentSession], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAgentSession.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AgentSession] {
        let len: Int32 = try readInt(&buf)
        var seq = [AgentSession]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAgentSession.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeArtifact: FfiConverterRustBuffer {
    typealias SwiftType = [Artifact]

    public static func write(_ value: [Artifact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeArtifact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Artifact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Artifact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeArtifact.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeDependencyStatus: FfiConverterRustBuffer {
    typealias SwiftType = [DependencyStatus]

    public static func write(_ value: [DependencyStatus], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDependencyStatus.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DependencyStatus] {
        let len: Int32 = try readInt(&buf)
        var seq = [DependencyStatus]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeDependencyStatus.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeIdea: FfiConverterRustBuffer {
    typealias SwiftType = [Idea]

    public static func write(_ value: [Idea], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdea.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Idea] {
        let len: Int32 = try readInt(&buf)
        var seq = [Idea]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeIdea.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypePlugin: FfiConverterRustBuffer {
    typealias SwiftType = [Plugin]

    public static func write(_ value: [Plugin], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePlugin.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Plugin] {
        let len: Int32 = try readInt(&buf)
        var seq = [Plugin]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypePlugin.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeProject: FfiConverterRustBuffer {
    typealias SwiftType = [Project]

    public static func write(_ value: [Project], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeProject.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Project] {
        let len: Int32 = try readInt(&buf)
        var seq = [Project]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeProject.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeSuggestedProject: FfiConverterRustBuffer {
    typealias SwiftType = [SuggestedProject]

    public static func write(_ value: [SuggestedProject], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSuggestedProject.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SuggestedProject] {
        let len: Int32 = try readInt(&buf)
        var seq = [SuggestedProject]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeSuggestedProject.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeTask: FfiConverterRustBuffer {
    typealias SwiftType = [Task]

    public static func write(_ value: [Task], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTask.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Task] {
        let len: Int32 = try readInt(&buf)
        var seq = [Task]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeTask.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterDictionaryStringTypeCachedFileInfo: FfiConverterRustBuffer {
    public static func write(_ value: [String: CachedFileInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeCachedFileInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: CachedFileInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: CachedFileInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeCachedFileInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterDictionaryStringTypeCachedProjectStats: FfiConverterRustBuffer {
    public static func write(_ value: [String: CachedProjectStats], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeCachedProjectStats.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: CachedProjectStats] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: CachedProjectStats]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeCachedProjectStats.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterDictionaryStringTypeProjectSessionState: FfiConverterRustBuffer {
    public static func write(_ value: [String: ProjectSessionState], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeProjectSessionState.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ProjectSessionState] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ProjectSessionState]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeProjectSessionState.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_hud_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_add_project() != 9786 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_capacitor_dir() != 14668 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_capture_idea() != 29080 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_check_dependency() != 39610 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_check_hook_health() != 9175 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_check_setup_status() != 11613 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_claude_dir() != 58851 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_create_project_claude_md() != 43265 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_agent_sessions() != 47314 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_all_agent_sessions() != 27566 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_all_session_states() != 34670 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_config() != 46018 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_hook_diagnostic() != 34425 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_hook_status() != 42858 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_ideas_file_path() != 48517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_primary_agent_session() != 36656 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_project_status() != 14524 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_session_state() != 25344 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_get_suggested_projects() != 38527 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_install_hook_binary_from_path() != 61995 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_install_hooks() != 3648 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_invalidate_agent_cache() != 27475 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_list_artifacts() != 5270 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_list_installed_agents() != 5136 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_list_plugins() != 12518 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_list_projects() != 27816 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_load_dashboard() != 23101 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_load_ideas() != 23681 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_load_ideas_order() != 374 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_remove_project() != 46288 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_run_startup_cleanup() != 39678 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_save_ideas_order() != 34756 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_update_idea_description() != 28488 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_update_idea_effort() != 54859 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_update_idea_status() != 241 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_update_idea_title() != 28398 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_update_idea_triage() != 43321 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_method_hudengine_validate_project() != 446 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_hud_core_checksum_constructor_hudengine_new() != 11939 {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
